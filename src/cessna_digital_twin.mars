model cessna_digital_twin

use Mars

layer AgentLayer as agentlayer
{	
	// Physics Values
	var gravity : real = 9.81 // m/s^2
	def Get_gravity() => return gravity
	
	// Callsign Handling
	var callsign_number : integer = 0
	
	def Get_callsign_number()
	{
		callsign_number = callsign_number + 1
		return callsign_number
	}
	
	//-----Communication Handling-----
	var frequency_blocked = false
	var sender_identifier = ""
	var receiver = ""
	var message_type = ""
	// either information is at first place "0" or contains multiple information as e.g. flight_path
	var message_information_path : List<Tuple<real, real>>
	var message_information_heading : real
	var message_information_bool : bool
	
	
	def Listen_receiver_on_frequency() => return receiver
	def Listen_sender_identifier_on_frequency() => return sender_identifier
	def Listen_message_type_on_frequency() => return message_type
	def Listen_message_information_path_on_frequency() => return message_information_path 
	def Listen_message_information_heading() => return message_information_heading
	def Listen_message_information_bool()=> return message_information_bool
	
	
	def Communicate_answer_on_frequency(_sender_identifier : string, _receiver : string, _message_type : string, _message_information_path : List<Tuple<real, real>>, _message_information_heading : real, _message_information_bool : bool)
	{
		if (frequency_blocked === false or _sender_identifier ==="Tower")
		{
			sender_identifier = _sender_identifier
			receiver = _receiver
			message_type = _message_type
			message_information_path  = _message_information_path 
			message_information_heading = _message_information_heading
			message_information_bool = _message_information_bool
			frequency_blocked = true
		}		
	}
	
	def Communicate_request_on_frequency(_sender_identifier : string, _receiver : string, _message_type : string)
	{
		if (frequency_blocked === false)
		{
			sender_identifier = _sender_identifier
			receiver = _receiver
			message_type = _message_type
			
			frequency_blocked = true
		}		
	}
	
	def Clear_frequency()
	{
		frequency_blocked = false
		sender_identifier = ""
		receiver = ""
		message_type = ""
		message_information_path = #[#(0.0, 0.0)]
	}
	
}

agent Weather on AgentLayer{
	initialize
	{
	}
	tick
	{ 
	}
	
	//Weather Values TODO: Think about another solution for weather
	external var wind_bearing : real // ° range 0..360
	external var wind_speed : real // m/s
	
	passive Get_wind_bearing() => return wind_bearing
	passive Get_wind_speed() => return wind_speed

	
	//help variables for density calculations
	var density_zero : real = 1.225 // kg/m^3 - mean sea level ISA
	external var temperature : real // C°
	var temperature_zero : real = 288.15 // Kelvin - mean sea level ISA
	var pressure_zero : real = 101325.0 //Pascal - mean sea level ISA
	external var pressure_QNH : real  //Pa, same es QNH since Airport elevation is zero
	var L_constant : real = 0.0065 // constant for dT/dh
	var C_K_constant : real = 273.15 // constant for transformation from celsius to kelvin
	var gas_constant : real = 287.3 // J/(kg*K)
		
	passive Get_density(height : real)
	{
		// 1. Calculate Pressure Height in relation to Airport Elevation, that is ZERO
		var pressure_height : real
		pressure_height = (temperature_zero / L_constant) * (1 - (pressure_QNH / pressure_zero)**(1/5.2561))
		// 2. Determine the ISA variation (since "Weather__temperature" is at airport)
		var pressure_height_temperature : real
		pressure_height_temperature = temperature_zero - L_constant * pressure_height
		var temperature_isa_delta : real
		temperature_isa_delta = (temperature + C_K_constant) - pressure_height_temperature
		// 3. Calculate the temperature and pressure for non ISA variation
		var temperature_non_isa : real
		temperature_non_isa = temperature_zero - L_constant * height + temperature_isa_delta
		var pressure_non_isa : real // note: it's calculated for isa, since non isa conditions are displayed in temperature
		pressure_non_isa = pressure_zero * (1 - height * L_constant / temperature_zero)**5.2561
		// 4. Calculate the density via the gas equation
		var Weather__density : real
		Weather__density = pressure_non_isa / (gas_constant * temperature_non_isa)
		return Weather__density
		
	}
	
	passive Get_temperature() => return temperature
}


// -----Agent Observer for spawning sequence-----
agent Observer on AgentLayer{
	initialize{
		state_list = #["PreflightInspection", "StartingEngine", "TakeOffPreparationRequest", "Taxiing", "TakeOffPreparation", "TakeOffHoldShortRequest", "TakeOffRequest", "TakeOff", "Climb", "LeavingFrequencyRequest", "LandingRequest","GoAround","Landing", "LeavingFrequency"]
		available_runway_heading = airportstade.Get_available_runway_heading_list()
		initialize_spawn_cor()
	}
	
	tick
	{	
		weather = nearest Weather // Has do be done here, since during initialization Weather agent might not be existing yet
		
		
		if (simtime % 150 === 0)
		{
			println "Simulation Time: " + simtime
			println "Number of Pilots in each State"
			each (var state in state_list)
			{
				var pilot_array = explore Pilot where [x => return x.Get_state() === state]
				println state + ": " + length(pilot_array)
			}
			println "-----End of information-----"
		}
		
		if (simtime === 1 or simtime % takeoff_spawn_interval === 0) // add for multiple spawns: or simtime % 100 === 0
		{
			spawn_pilot_and_aircraft_on_ground()
		}
		
		if (simtime === 1 or simtime % landing_spawn_interval === 0) // add for multiple spawns: or simtime % 100 === 0
		{
			spawn_pilot_and_aircraft_landing()
		}
	}
	
	//Setting
	var state_list = new List<string>
	var formula = new Formula()
	var airportstade = new AirportStade()
	
	//-----Spawn Handling-----
	// Apron spawn coordinates and handling
	external var number_of_spawning_points : integer
	external var takeoff_spawn_interval : integer
	external var landing_spawn_interval: integer
	var left_xcor : real
	var left_ycor : real 
	var right_xcor : real 
	var right_ycor : real
	var spawn_xcor_list = new List<real>()
	var spawn_ycor_list = new List<real>()
	var spawn_location_number : integer
	
	// for landing spawn management
	var available_runway_heading : List<real>
	var runway_heading_calculated : real
	var weather : Weather
	
	def initialize_spawn_cor()
	{
		left_xcor = airportstade.Get_left_apron_coordinates().Item1
		left_ycor = airportstade.Get_left_apron_coordinates().Item2
		right_xcor = airportstade.Get_right_apron_coordinates().Item1
		right_ycor = airportstade.Get_right_apron_coordinates().Item2
		var temp_deltastep_xcor = (left_xcor - right_xcor) / (number_of_spawning_points-1)
		var temp_deltastep_ycor = (left_ycor - right_ycor) / (number_of_spawning_points-1)
		for (var i = 0; i < number_of_spawning_points; i++)
		{
			spawn_xcor_list.Add(left_xcor - temp_deltastep_xcor * i)
			spawn_ycor_list.Add(left_ycor - temp_deltastep_ycor * i)
		}
		spawn_location_number = 0
	}
		
	def spawn_pilot_and_aircraft_on_ground()
	{
		// only spawn, when no aircraft is nearby, else go to next spawn location and try again until tried at all location
		var spawn_successful = false
		var i = 0
		while (i < number_of_spawning_points and spawn_successful === false)
		{
			i = i + 1
			var spawn_cor = #(spawn_xcor_list.Get(spawn_location_number), spawn_ycor_list.Get(spawn_location_number))
			var aircraft_array = explore Aircraft where [x => return formula.haversine(x.Get_position(), spawn_cor) < 10]
			if (length(aircraft_array) === 0)
			{
				// spawn order is important, since pilot needs to find an aircraft! 
				spawn Aircraft at spawn_cor
				spawn Pilot at spawn_cor
				spawn_successful = true
			}
			spawn_location_number = spawn_location_number + 1
			
			if (spawn_location_number >= number_of_spawning_points)
			{
				spawn_location_number = 0
			}
		}
	}
		
	def spawn_pilot_and_aircraft_landing()
	{
		var wind_bearing = weather.Get_wind_bearing()
		runway_heading_calculated = formula.calculate_runway_heading(available_runway_heading, wind_bearing)
		var landing_spawn_cor = airportstade.Get_landing_spawning_point(runway_heading_calculated)
		
		var spawn_aircraft = spawn Aircraft at landing_spawn_cor
		spawn_aircraft.Initialize_landing(runway_heading_calculated)
		var spawn_pilot = spawn Pilot at landing_spawn_cor
		spawn_pilot.Initialize_landing(runway_heading_calculated)
		
	}
}

// -----Agent Pilot flying the aircraft-----
agent Pilot on AgentLayer{
		
	initialize
	{	
		//General Initialization for Pilot starting from the ground
		myAircraft = nearest Aircraft where [it => return it.Get_occupy_bool() === false]
		myAircraft.Set_occupied()		
		myAircraft_callsign = myAircraft.Get_callsign() // save aircraft callsign --> IDENTIFIER!
		weather = nearest Weather //only ne weather agent existing
		update_general_values() // so first row of csv is not empty
		state = "PreflightInspection" // first state for starting on ground
		current_activity = "Initialization:)"
		event_info = "None"
		
		takeoff_distance = 0 // for measuring takeoff distance later
		
		// Pilot attributes and share them with classes
		age = age_min + random((age_max - age_min) + 1)
		flight_experience = random((age - age_min) * flight_experience_max / (age_max - age_min))
		timehandler.initialize_variables(age, flight_experience, flight_experience_max, age_max, age_min)
	}
		
	tick
	{	
		if (state === "PreflightInspection"){
			PreflightInspection_action()
		}
		
		else if (state === "StartingEngine"){
			StartingEngine_action()
		}
		
		else if (state === "TakeOffPreparationRequest"){
			TakeOffPreparationRequest_action()
		}
		
		else if (state === "Taxiing"){
			Taxiing_action()
		}
		
		else if (state === "TakeOffPreparation"){
			TakeOffPreparation_action()
		}
		
		else if (state === "TakeOffHoldShortRequest"){
			TakeOffHoldShortRequest_action()
		}
		
		else if (state === "TakeOffRequest"){
			TakeOffRequest_action()
		}
		
		else if (state === "TakeOff"){
			TakeOff_action()
		}
		
		else if (state === "Climb"){
			Climb_action()
		}
		
		else if (state === "LeavingFrequencyRequest"){
			LeavingFrequencyRequest_action()
		}
		
		else if (state === "LandingRequest"){
			LandingRequest_action()
		}
		
		else if (state === "GoAround"){
			GoAround_action()
		}
		
		else if (state === "Landing"){
			Landing_action()
		}
		
		else if (state === "LeavingFrequency"){
			LeavingFrequency_action()
		}
		
		update_general_values()
	}
	
	
	//-----General Values and functions (Settings)-----
	observe var Latitude : real
	observe var Longitude : real
	observe var myAircraft_callsign : string
	observe var state : string
	observe var current_activity : string
	observe var event_info : string
	observe var takeoff_distance : real
	
	//Classes and Agents
	var myAircraft : Aircraft // for accessing the real aircraft
	var weather : Weather
	var timehandler = new TimeHandler()
	var formula = new Formula()
	
	//help variables
	var temp_throttle_value : real // for throttle management between 0...1
	var temp_pitch_value : real // for pitch management
	var next_action : string
	var first_action_set : bool = false // temporary auxiliary variable for first action in each state
	var taxi_path : List<Tuple<real, real>> // for saving taxi instructions
	var active_taxi_point_number : integer = 0 // for indicating actual taxi point
	var heading_information : real // for saving heading value from atc
	var state_after_taxiing : string  // since taxi state has multiple use
	var distance_to_next_point : real // calculated distance to a point in [m]
	var first_fixing_attempt : bool = true // checker if first repair attempt has been done
	var request_attempts : integer // checker for communication attempt
	var killme_info : string //info for "killme" sequence
	
	// settings for aircraft handling
	external var TakeOff__V_rotate : real  // Speed on where to rotate (for cessna152 its normally at 25)
	external var Taxiing__spacing_to_next_aircraft : real // distance kept to the next aircraft (when start braking)
	external var Taxiing__angle_of_vision : real // angle of vision when looking with current heading
	
	def go_to_next_state(_state : string)
	{
		state = _state
		first_action_set = false
		if (state === "Taxiing")
		{
			//reset placed here
			active_taxi_point_number = 0
		}
	}
	
	def remove_me_and_my_aircraft(info : string)
	{
		event_info = "End flight mission due to " + info
		myAircraft.Remove()
		kill me
	}

	def update_general_values()
	{
		pos at(myAircraft.Get_position())
		Longitude = xcor
		Latitude = ycor
		current_activity = next_action
	}
	
	// functions for observer agent
	passive Get_state() => return state  
	passive Initialize_landing(heading : real)
	{
		state = "LandingRequest"
		heading_information = heading
	}
	
	//-----General Pilot Values and functions-----
	observe var age: integer // years
	observe var flight_experience : real // years
		
	//Settings
	var age_max : integer = 75
	var age_min : integer = 18
	var flight_experience_max : real = 5700.0 // hours
	
	
	//-----State Preflight Inspection-----
	
	// help function:
	def skip_action(base_probability: real, action_name : string) : bool
	{
		// the probability of skiping repair action increases with flight experience
		var random_value = random(10**6)/10**6
		var threshold_value = base_probability + flight_experience/flight_experience_max * 0.1
		if (random_value >= threshold_value)
		{
			return false
		}
		else
		{
			event_info = "Skipped " + action_name
			return true
		}
	}
	
	// variables
	external var Check_RWT__water_sediments_skip_probability : real
	external var Check_Engine__oil_skip_probability : real
	external var Check_LWT__water_sediments_skip_probability : real
	
	def PreflightInspection_action()
	{
		// Flag for first action and architecture like this avoids loose of one tick
		if (first_action_set === false)
		{
			next_action = "Check_TireRightMainWheel__inflation"
			first_action_set = true
		}
		
		if (next_action === "Check_TireRightMainWheel__inflation")
		{
			timehandler.create_action_duration(10, 10, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_TireRightMainWheel__inflation()
				if (check_value >= 0)
				{
					next_action = "Check_RWT__water_sediments"
				}
			}	
		}		
		
		else if (next_action === "Check_RWT__water_sediments")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_RWT__water_sediments()
				next_action = "Check_RWT__fuel_quantity"
				
				if (check_value === true)
				{
					if(skip_action(Check_RWT__water_sediments_skip_probability, "Repair_RWT__water_sediments") === false)
					{
						next_action = "Repair_RWT__water_sediments"
					}
					
				}
			}
		}
		
		else if(next_action === "Repair_RWT__water_sediments")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Repair_Visual_RWT__water_sediments()
				next_action = "Check_RWT__fuel_quantity"
			}
		}
		
		else if (next_action === "Check_RWT__fuel_quantity")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_RWT__fuel_quantity()
				if (check_value >= 0) 
				{
					next_action = "Check_Engine__oil"
				}
			}
		}
				
		else if (next_action === "Check_Engine__oil")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_Engine__oil()
				next_action = "Check_TireNoseWheel__inflation"
				
				if (check_value < myAircraft.Get_Engine__oil_min())
				{
					if (skip_action(Check_Engine__oil_skip_probability, "Refill_Engine__oil") === false)
					{
						next_action = "Refill_Engine__oil"
					}					
				}
			}
		}
		
		else if(next_action === "Refill_Engine__oil")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Refill_Visual_Engine__oil()
				next_action = "Check_TireNoseWheel__inflation"
			}
		}
		
		else if (next_action === "Check_TireNoseWheel__inflation")
		{
			timehandler.create_action_duration(10, 10, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_TireNoseWheel__inflation()
				if (check_value >= 0) 
				{
					next_action = "Check_TireLeftMainWheel__inflation"
				}
			}
		}
		
		else if (next_action === "Check_TireLeftMainWheel__inflation")
		{
			timehandler.create_action_duration(10, 10, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_TireLeftMainWheel__inflation()
				if (check_value >= 0) 
				{
					next_action = "Check_LWT__water_sediments"
				}
			}
		}				
		
		else if(next_action === "Check_LWT__water_sediments")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_LWT__water_sediments()
				next_action = "Check_LWT__fuel_quantity"
				
				if (check_value === true)
				{
					if(skip_action(Check_LWT__water_sediments_skip_probability, "Repair_LWT__water_sediments") === false)
					{
						next_action = "Repair_LWT__water_sediments"
					}
				}
			}
		}
		
		else if(next_action === "Repair_LWT__water_sediments")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Repair_Visual_LWT__water_sediments()
				next_action = "Check_LWT__fuel_quantity"
			}
		}					
					
		else if (next_action === "Check_LWT__fuel_quantity")
		{
			timehandler.create_action_duration(20, 20, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_LWT__fuel_quantity()
				if (check_value >= 0) 
				{
					next_action = "End_of_Actions"
				}
			}
		}
			
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("StartingEngine")
		}
	}
	
	
	
	//-----State Starting Engine-----
	
	//variables
	external var Set_Engine__mixture_control_skip_probability : real
	external var Check_Instrument_Engine__oil_pressure_skip_probability : real
	external var Check_Instrument_Engine__oil_temperature_skip_probability : real
	
	def StartingEngine_action()
	{
		if (first_action_set === false)
		{
			next_action = "Set_Brake__parking_brake"
			first_action_set = true
		}
		
		if (next_action === "Set_Brake__parking_brake")
		{
			timehandler.create_action_duration(4, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Set_Brake__parking_brake("SET")
				next_action = "Set_Engine__mixture_control"
			}
		}
		
		else if (next_action === "Set_Engine__mixture_control")
		{
			timehandler.create_action_duration(4, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				if(skip_action(Set_Engine__mixture_control_skip_probability, "Set_Engine__mixture_control") === false)
				{
					Set_Engine__mixture_control("RICH") // set to rich
				}
				next_action = "Set_CIP__master_switch"
			}
		}
		
		else if (next_action === "Set_CIP__master_switch")
		{
			timehandler.create_action_duration(4, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Set_CIP__master_switch("ON")
				next_action = "Apply_Engine__throttle"
			}
		}
		
		else if (next_action === "Apply_Engine__throttle")
		{
			timehandler.create_action_duration(4, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				temp_throttle_value = 0.10 // idle throttle
				Apply_Engine__throttle(temp_throttle_value)
				next_action = "Set_Engine__ignition_switch_START"
			}
		}
		
		else if (next_action === "Set_Engine__ignition_switch_START")
		{
			timehandler.create_action_duration(4, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Set_Engine__ignition_switch("START")
				next_action = "Check_Engine__running"
			}
		}
		
		else if (next_action === "Check_Engine__running")
		{
			timehandler.create_action_duration(2, 1, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				var check_value = Check_Visual_Engine__running()
				if (check_value === true)
				{
					next_action = "Set_Engine__ignition_switch_BOTH"
				}
				else if (check_value === false)
				{
					next_action = "Check_Engine__running"
				}
			}
		}
			
		else if (next_action === "Set_Engine__ignition_switch_BOTH")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Set_Engine__ignition_switch("BOTH")
				next_action = "Check_Instrument_Engine__oil_pressure"
			}
		}
		
		else if (next_action === "Check_Instrument_Engine__oil_pressure")
		{
			timehandler.create_action_duration(30, 2, "pilot_age_and_experience") // includes holding pattern
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				next_action = "Check_Instrument_Engine__oil_temperature"
				if (Check_Instrument_Engine__oil_pressure() < myAircraft.Get_Engine__oil_pressure_normal_min())
				{
					if(skip_action(Check_Instrument_Engine__oil_pressure_skip_probability, "Check_Instrument_Engine__oil_pressure") === false)
					{
						if (first_fixing_attempt === true)
						{
							event_info = "Engine__oil_pressure too low, back to state PreflightInspection"
							go_to_next_state("PreflightInspection")
							first_fixing_attempt = false
							Set_Engine__ignition_switch("OFF")
						}
						else
						{
							killme_info = "low engine oil pressure"
							go_to_next_state("LeavingFrequency")
						}
					}
				}
			}
		}
		
		else if (next_action === "Check_Instrument_Engine__oil_temperature")
		{
			timehandler.create_action_duration(3, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				next_action = "End_of_Actions"
				if (Check_Instrument_Engine__oil_temperature() > myAircraft.Get_Engine__oil_temperature_normal_max())
				{
					if(skip_action(Check_Instrument_Engine__oil_temperature_skip_probability, "Check_Instrument_Engine__oil_temperature") === false)
					{
						if (first_fixing_attempt === true)
						{
							event_info = "Engine__oil_temperature too high, back to state PreflightInspection"
							go_to_next_state("PreflightInspection")
							first_fixing_attempt = false
							Set_Engine__ignition_switch("OFF")
						}
						else
						{
							killme_info = "high engine oil temperature"
							go_to_next_state("LeavingFrequency")
						}
					}
				}				
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("TakeOffPreparationRequest")
		}
	}
	
	
	//-----State TakeOffPreparationRequest-----
	def TakeOffPreparationRequest_action()
	{
		if (first_action_set === false)
		{
			next_action = "Communicate_on_frequency"
			first_action_set = true
		}
		
		if (next_action === "Communicate_on_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Communicate_request_on_frequency(myAircraft_callsign, "Tower", "RequestTakeOffPreparationPoint")
				next_action = "Listen_receiver_on_frequency"
			}
		}
		
		else if (next_action === "Listen_receiver_on_frequency")
		{
			var temp_receiver = agentlayer.Listen_receiver_on_frequency()
			if (temp_receiver === myAircraft_callsign)
			{
				taxi_path = agentlayer.Listen_message_information_path_on_frequency()
				next_action = "Clear_frequency"
			}
			
			//retry contacting tower after a specific period of time
			timehandler.create_action_duration(10, 5, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				next_action = "Communicate_on_frequency"
			}
		}
		
		// to make sure that message is not instantly deleted and simulate processing time of incoming message and blockage
		else if (next_action === "Clear_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Clear_frequency()
				next_action = "End_of_Actions"
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("Taxiing")
			state_after_taxiing = "TakeOffPreparation"
		}
	}
	
	
	//-----State TakeOff Preparation
	def TakeOffPreparation_action()
	{
		if (first_action_set === false)
		{
			next_action = "Set_Brake__parking_brake"
			first_action_set = true
		}
		
		if (next_action === "Set_Brake__parking_brake")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Set_Brake__parking_brake("SET")
				next_action = "Check_all_Flight_Instruments"
			}
		}
		
		else if (next_action === "Check_all_Flight_Instruments")
		{
			timehandler.create_action_duration(20, 10, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Check_Instrument_LWT__fuel_quantitity()
				Check_Instrument_RWT__fuel_quantitity()
				Check_Instrument_Aircraft__height()
				Check_Instrument_Aircraft__rate_of_climb()
				Check_Instrument_Aircraft__pitch()
				Check_Instrument_Aircraft__true_air_speed()
				next_action = "Set_Engine__mixture_control"
			}
		}
		
		else if(next_action === "Set_Engine__mixture_control")
		{
			timehandler.create_action_duration(4, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				if(skip_action(Set_Engine__mixture_control_skip_probability, "Set_Engine__mixture_control") === false)
				{
					Set_Engine__mixture_control("RICH") // set to rich
				}
				next_action = "Apply_Engine__throttle_to_1700RPM"
				temp_throttle_value = 0.20 //starting point for throttle
			}
		}
		
		else if (next_action === "Apply_Engine__throttle_to_1700RPM")
		{
			//Instructions are to apply throttle, so that rpm equal 1700
			timehandler.create_action_duration(1, 1, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Apply_Engine__throttle(temp_throttle_value)
				if (Check_Instrument_Engine__RPM < 1700)
				{
					temp_throttle_value = temp_throttle_value + 0.05
					next_action = "Apply_Engine__throttle_to_1700RPM"
				}
				else
				{
					next_action = "Check_Engine_Instruments"
				}
			}
		}
		
		else if(next_action === "Check_Engine_Instruments")
		{
			timehandler.create_action_duration(10, 5, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				//usually here should be a magneto with RPM check
				
				if (Check_Instrument_Engine__oil_temperature() > myAircraft.Get_Engine__oil_temperature_normal_max())
				{
					if(skip_action(Check_Instrument_Engine__oil_temperature_skip_probability, "Check_Instrument_Engine__oil_temperature") === false)
					{
						killme_info = "high engine oil temperature"
						go_to_next_state("LeavingFrequency")
					}
				}
				
				if (Check_Instrument_Engine__oil_pressure() < myAircraft.Get_Engine__oil_pressure_normal_min())
				{
					if(skip_action(Check_Instrument_Engine__oil_pressure_skip_probability, "Check_Instrument_Engine__oil_pressure") === false)
					{
						killme_info = "low engine oil pressure"
						go_to_next_state("LeavingFrequency")
					}
				}
				
				next_action = "Apply_Engine__throttle_idle"
				temp_throttle_value = 0.10 //idle throttle
			}
		}
		
		else if(next_action === "Apply_Engine__throttle_idle")
		{
			timehandler.create_action_duration(3, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Apply_Engine__throttle(temp_throttle_value)
				next_action = "End_of_Actions"
			}
		}
		
		
		if (next_action === "End_of_Actions")
			{
				go_to_next_state("TakeOffHoldShortRequest")
			}
	}
	
	
	
	//-----State TakeOffHoldShortRequest-----
	def TakeOffHoldShortRequest_action()
	{
		if (first_action_set === false)
		{
			next_action = "Communicate_on_frequency"
			first_action_set = true
		}
		
		if (next_action === "Communicate_on_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Communicate_request_on_frequency(myAircraft_callsign, "Tower", "RequestTakeOffHoldShortPoint")
				next_action = "Listen_receiver_on_frequency"
			}
		}
		
		else if (next_action === "Listen_receiver_on_frequency")
		{
			var temp_receiver = agentlayer.Listen_receiver_on_frequency()
			if (temp_receiver === myAircraft_callsign)
			{
				taxi_path = agentlayer.Listen_message_information_path_on_frequency()
				next_action = "Clear_frequency"
			}
			
			//retry contacting tower after a specific period of time
			timehandler.create_action_duration(10, 5, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				next_action = "Communicate_on_frequency"
			}
		}
		
		// to make sure that message is not instantly deleted and simulate processing time of incoming message and blockage
		else if (next_action === "Clear_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Clear_frequency()
				next_action = "End_of_Actions"
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("Taxiing")
			state_after_taxiing = "TakeOffRequest"
		}
	}
	
	
	
	//-----State TakeOffHoldShortRequest-----
	def TakeOffRequest_action()
	{
		if (first_action_set === false)
		{
			next_action = "Communicate_on_frequency"
			first_action_set = true
		}
		
		if (next_action === "Communicate_on_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Communicate_request_on_frequency(myAircraft_callsign, "Tower", "RequestTakeOff")
				next_action = "Listen_receiver_on_frequency"
			}
		}
		
		else if (next_action === "Listen_receiver_on_frequency")
		{
			var temp_receiver = agentlayer.Listen_receiver_on_frequency()
			if (temp_receiver === myAircraft_callsign)
			{
				var temp_bool = agentlayer.Listen_message_information_bool()
				if (temp_bool === true)
				{
					taxi_path = agentlayer.Listen_message_information_path_on_frequency()
					heading_information = agentlayer.Listen_message_information_heading()
					next_action = "Clear_frequency"
				}
				else
				{
					agentlayer.Clear_frequency()
					next_action = "Wait_to_communicate_on_frequency"
				}
			}
			//retry contacting tower after a specific period of time
			timehandler.create_action_duration(15, 5, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				next_action = "Communicate_on_frequency"
			}
		}
		
		else if (next_action === "Wait_to_communicate_on_frequency")
		{
			timehandler.create_action_duration(20, 5, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				next_action = "Communicate_on_frequency"
			}
		}
		
		// to make sure that message is not instantly deleted and simulate processing time of incoming message and blockage
		else if (next_action === "Clear_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Clear_frequency()
				next_action = "End_of_Actions"
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("Taxiing")
			state_after_taxiing = "TakeOff"
		}
	}
	

	//-----State TakeOff-----
	//TODO: Add Instrument Screening and better mechanism for take off
	def TakeOff_action()
	{
		if (first_action_set === false)
		{
			next_action = "Set_Throttle_and_Heading"
			first_action_set = true
		}
		
		// -----ONLY to evaluate the take off distance-----
		if (myAircraft.Get_Aircraft__flight_phase() === "on-ground")
		{
			takeoff_distance = takeoff_distance + myAircraft.Get_Aircraft__ground_speed_x() * 1 //since ticksize is one
		}
		
		if (next_action === "Set_Throttle_and_Heading")
		{
			timehandler.create_action_duration(4, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				// Set Aircraft Heading
				Set_Aircraft__heading_bearing(heading_information)
				Apply_Engine__throttle(1.0)
				Apply_Brake__deceleration(0.0)
				temp_pitch_value = 0
				next_action = "ReadyForRotate"
			}
		}
		
		else if (next_action === "ReadyForRotate")
		{
			timehandler.create_action_duration(1, 1, "pilot_age_and_experience")  // simulating check of instrument
			if (timehandler.hold_action_time(timehandler.action_duration))  
			{
				if (Check_Instrument_Aircraft__true_air_speed() > TakeOff__V_rotate)
				{
					temp_pitch_value = temp_pitch_value + 2
					Apply_Aircraft__pitch(temp_pitch_value)
					if (temp_pitch_value >= 8)
					{
						next_action = "HoldAircraft"
					}
					
				}
			}
		}
		
		else if (next_action === "HoldAircraft")
		{
			timehandler.create_action_duration(5, 1, "pilot_age_and_experience") 
			if (timehandler.hold_action_time(timehandler.action_duration))  
			{
				if (Check_Instrument_Aircraft__height() > 0)
				{
					next_action = "End_of_Actions"
				}
				else
				{
					temp_pitch_value = 0
					Apply_Aircraft__pitch(temp_pitch_value)
					TakeOff__V_rotate = TakeOff__V_rotate + 5
					next_action = "ReadyForRotate"
				}
			}
		}
		
		else if (next_action === "ControlAircraft")
		{
			timehandler.create_action_duration(3, 1, "pilot_age_and_experience")  // simulating check of instrument every 2 sec
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				if (Hear_Aircraft__stall_sound() === true)
				{
					temp_pitch_value = temp_pitch_value - 1
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() > 3)
				{
					if (Feel_Aircraft__deceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value - 0.5
					}
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() < 1)
				{
					if (Feel_Aircraft__acceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value + 0.5
					}
				}
				Apply_Aircraft__pitch(temp_pitch_value)
				
				if (Check_Instrument_Aircraft__height() > 300)
				{
					next_action = "End_of_Actions"
				}
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("Climb")
		}	
		
		
		// TODO: Think about better handling and protocol, when engine failure occur
		if (myAircraft.Get_Engine__failure() === true)
		{
			killme_info = "Engine__Failure during TakeOff"
			go_to_next_state("LeavingFrequency")
		}
	}
	
	
	//-----State Climb-----
	def Climb_action()
	{
		if (first_action_set === false)
		{
			next_action = "ControlAircraft"
		}
		
		if (next_action === "ControlAircraft")
		{
			timehandler.create_action_duration(3, 1, "pilot_age_and_experience")  // simulating check of instrument every 2 sec
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				if (Hear_Aircraft__stall_sound() === true)
				{
					temp_pitch_value = temp_pitch_value - 1
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() > 3)
				{
					if (Feel_Aircraft__deceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value - 0.5
					}
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() < 1)
				{
					if (Feel_Aircraft__acceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value + 0.5
					}
				}
				Apply_Aircraft__pitch(temp_pitch_value)
				
				if (Check_Instrument_Aircraft__height() > 250)
				{
					next_action = "End_of_Actions"
				}
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("LeavingFrequencyRequest")
		}
	}
	
	
	//-----State LeavingFrequencyRequest-----
	def LeavingFrequencyRequest_action()
	{
		if (first_action_set === false)
		{
			next_action = "Communicate_on_frequency"
			first_action_set = true
		}
		
		if (next_action === "Communicate_on_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Communicate_request_on_frequency(myAircraft_callsign, "Tower", "RequestLeavingAirpsace")
				next_action = "Listen_receiver_on_frequency"
			}
		}
		
		else if (next_action === "Listen_receiver_on_frequency")
		{
			var temp_receiver = agentlayer.Listen_receiver_on_frequency()
			if (temp_receiver === myAircraft_callsign)
			{
				var temp_bool = agentlayer.Listen_message_information_bool()
				if (temp_bool === true) //always true so far
				{
					next_action = "Clear_frequency"
				}
			}
			
			//retry contacting tower after a specific period of time
			timehandler.create_action_duration(10, 5, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				next_action = "Communicate_on_frequency"
			}
		}
		
		// to make sure that message is not instantly deleted and simulate processing time of incoming message and blockage
		else if (next_action === "Clear_frequency")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Clear_frequency()
				next_action = "End_of_Actions"
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("LeavingFrequency")
			killme_info = "TakeOffComplete"
		}
	}
	
	
	//-----State LandingRequest-----
	def LandingRequest_action()
	{
		if (first_action_set === false)
		{
			next_action = "Communicate_on_frequency"
			first_action_set = true
			request_attempts = 0
		}
		
		if (next_action === "Communicate_on_frequency")
		{
			timehandler.create_action_duration(3, 0, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Communicate_request_on_frequency(myAircraft_callsign, "Tower", "RequestLanding")
				next_action = "Listen_receiver_on_frequency"
			}
		}
		
		else if (next_action === "Listen_receiver_on_frequency")
		{
			var temp_receiver = agentlayer.Listen_receiver_on_frequency()
			if (temp_receiver === myAircraft_callsign)
			{
				taxi_path = agentlayer.Listen_message_information_path_on_frequency()
				var temp_bool = agentlayer.Listen_message_information_bool()
				if (temp_bool === true)
				{
					next_action = "Clear_frequency"
				}
				else
				{
					agentlayer.Clear_frequency() // and attempt after time below
				}
			}
			
			//retry contacting tower after a specific period of time
			timehandler.create_action_duration(10, 0, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				if (request_attempts >= 3)
				{
					go_to_next_state("GoAround")
				}
				else
				{
					request_attempts = request_attempts + 1
					next_action = "Communicate_on_frequency"
				}				
			}
		}
		
		// to make sure that message is not instantly deleted and simulate processing time of incoming message and blockage
		else if (next_action === "Clear_frequency")
		{
			timehandler.create_action_duration(3, 0, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				agentlayer.Clear_frequency()
				next_action = "End_of_Actions"
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("Landing")
		}
	}
	
	def GoAround_action()
	{
		if (first_action_set === false)
		{
			next_action = "GoAround"
			first_action_set = true
			temp_pitch_value = 3.5
		}
		
		else if (next_action === "GoAround")
		{
			if (Hear_Aircraft__stall_sound() === true)
				{
					temp_pitch_value = temp_pitch_value - 1
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() > 3)
				{
					if (Feel_Aircraft__deceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value - 0.5
					}
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() < 2)
				{
					if (Feel_Aircraft__acceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value + 0.5
					}
				}
			Set_Aircraft__heading_bearing(myAircraft.Get_Aircraft_heading_bearing() + 5.0)
			Apply_Aircraft__pitch(temp_pitch_value)
			Apply_Engine__throttle(1.0)
			if (Check_Instrument_Aircraft__height() > 100)
			{
				next_action = "End_of_Actions"
			}			
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("LeavingFrequency")
			killme_info = "Go around, no Landing Clearance"
		}
		
	}
	
	//-----State Landing-----
	//TODO: Improve simultaneous landing and communication action feature (done after each other)
	def Landing_action()
	{
		if (first_action_set === false)
		{
			next_action = "DescentAircraft"
			first_action_set = true
			temp_throttle_value = 0.1
			temp_pitch_value = 3.5
		}
		
		// controlling the airplane for descent is difficult, as it affords simultanous throttle and pitch control -> simple solution
		else if (next_action === "DescentAircraft")
		{
			timehandler.create_action_duration(3, 1, "pilot_age_and_experience")  // simulating check of instrument every few sec
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Set_Aircraft__heading_bearing(heading_information)
				//TODO: Control behavior optimization, since pitch, throttle, ROC and TAS are all interdependent (AI Pilot/Bot)
				// pitch control
				if (Hear_Aircraft__stall_sound() === true)
				{
					temp_pitch_value = temp_pitch_value - 1
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() > -0.5)
				{
					if (Feel_Aircraft__deceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value - 0.5
					}
				}
				else if (Check_Instrument_Aircraft__rate_of_climb() < -2)
				{
					if (Feel_Aircraft__acceleration_z === false)
					{
						temp_pitch_value = temp_pitch_value + 0.5
					}
				}
				Apply_Aircraft__pitch(temp_pitch_value)
				
				//speed control
				if (Check_Instrument_Aircraft__true_air_speed() > 35)
				{	
					if (Feel_Aircraft__deceleration_x() === false)
					{
						temp_throttle_value = temp_throttle_value - 0.05
					}
				}
				else if (Check_Instrument_Aircraft__true_air_speed() < 25)
				{
					if (Feel_Aircraft__acceleration_x() === false)
					{
						temp_throttle_value = temp_throttle_value + 0.05
					}
				}
				if (temp_throttle_value < 0.05)
				{
					temp_throttle_value = 0.05
				}
				Apply_Engine__throttle(temp_throttle_value)
				
				if (Check_Instrument_Aircraft__height() <= 0)
				{
					next_action = "ApplyBrake"
				}
			}
		}
		
		else if (next_action === "ApplyBrake")
		{
			Apply_Engine__throttle(0.1)
			Apply_Aircraft__pitch(0.0)
			Apply_Brake__deceleration(0.7)
			timehandler.create_action_duration(2, 1, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				if (Check_Visual_Aircraft__ground_speed_x() < 9)
				{
					next_action = "Taxiing_off_runway"
				}
			}
		}
		
		else if (next_action === "Taxiing_off_runway")
		{
			// Get active Taxi point
			var active_taxi_point = taxi_path.Get(active_taxi_point_number)
			// Set Aircraft Heading
			var myAircraft__heading = formula.bearing(myAircraft.Get_position(), active_taxi_point)
			Set_Aircraft__heading_bearing(myAircraft__heading)
			//Distance and throttle handling
			distance_to_next_point = formula.haversine(myAircraft.Get_position(), active_taxi_point)
			Taxiing_normal()
			
			if (distance_to_next_point < 15)
			{
				next_action = "End_of_Actions"
			}
		}
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state("Taxiing")
			state_after_taxiing = "LeavingFrequency"
			killme_info = "LandingComplete"
		}	
	}
	
	
	//-----State Leaving Frequency-----
	def LeavingFrequency_action()
	{
		//TODO: Remove this workaround, when bug is fixed, where "removed" pilots and aircrafts
		//can still be found via explore function, which leads to unwanted collision
		myAircraft.Teleport(#(9.501273,53.559141)) // Workaround
		
		timehandler.create_action_duration(3, 0, "None")
		if (timehandler.hold_action_time(timehandler.action_duration))
		{
			remove_me_and_my_aircraft(killme_info)
		}
		
	}
	
	
	//-----State Taxiing in general-----
	//TODO: Here the speed is checked against ground speed, normally the speed on the speed indicator in
	//cockpit shows the true airspeed, but with strong headwind this would lead to pilots not moving
	
	// defining help functions for taxiing
	def Taxiing_brake(throttle : real, brake : real)
	{
		temp_throttle_value = throttle
		Apply_Brake__deceleration(brake)
		Apply_Engine__throttle(temp_throttle_value)
	}
	
	def Taxiing_to_final_point()  // rolling to the end	
	{
		if (distance_to_next_point < 20)
		{
			if (distance_to_next_point < 10)
			{
				Taxiing_brake(0.1, 0.8)
				next_action = "End_of_Actions"
			}
			else
			{
				if (Check_Visual_Aircraft__ground_speed_x() > 5)
				{
					Taxiing_brake(0.1, 0.2)
				}
				else if(Check_Visual_Aircraft__ground_speed_x() < 1)
				{
					Apply_Brake__deceleration(0.0)
					if (Feel_Aircraft__acceleration_x() === false)
					{
						temp_throttle_value = temp_throttle_value + 0.10
						Apply_Engine__throttle(temp_throttle_value)
					}
				}
			}
		}
		else
		{
			Taxiing_normal()
		}
	}
	
	def Taxiing_normal()  // Throttle handling in normal case	
	{
		Apply_Brake__deceleration(0.0)
		
		// taxi throttle control
		if (Check_Visual_Aircraft__ground_speed_x() > 6)
		{	
			if (Feel_Aircraft__deceleration_x() === false)
			{
				temp_throttle_value = temp_throttle_value - 0.10
			}
		}
		else if (Check_Visual_Aircraft__ground_speed_x() < 2)
		{
			if (Feel_Aircraft__acceleration_x() === false)
			{
				temp_throttle_value = temp_throttle_value + 0.30
			}
		}
		else if (Check_Visual_Aircraft__ground_speed_x() < 5)
		{
			if (Feel_Aircraft__acceleration_x() === false)
			{
				temp_throttle_value = temp_throttle_value + 0.05
			}
		}
		if (temp_throttle_value < 0.05)
		{
			temp_throttle_value = 0.05
		}
		Apply_Engine__throttle(temp_throttle_value)
	}
	
	def Taxiing_action()
	{
		var taxi_path_points = taxi_path.Size()
		if (first_action_set === false)
		{
			next_action = "Set_Brake__parking_brake"
			first_action_set = true
		}
		
		if (next_action === "Set_Brake__parking_brake")
		{
			timehandler.create_action_duration(2, 2, "pilot_age_and_experience")
			if (timehandler.hold_action_time(timehandler.action_duration))
			{
				Set_Brake__parking_brake("OFF")
				Apply_Brake__deceleration(0.0)
				next_action = "Taxiing"
			}
		}
		
		else if (next_action === "Taxiing")
		{
			//help variable
			var avoid_collision = false
			// Get active Taxi point
			var active_taxi_point = taxi_path.Get(active_taxi_point_number)
			// Set Aircraft Heading
			var myAircraft__heading = formula.bearing(myAircraft.Get_position(), active_taxi_point)
			Set_Aircraft__heading_bearing(myAircraft__heading)
			//Distance and throttle handling
			distance_to_next_point = formula.haversine(myAircraft.Get_position(), active_taxi_point)
			
			
			//Check for collision TODO: Add collision conflict handling (e.g. when two aircrafts won't move)
			var aircraft_array = explore Aircraft where [x => return formula.haversine(myAircraft.Get_position(), x.Get_position()) < Taxiing__spacing_to_next_aircraft]
			if (length(aircraft_array) > 1) // since list contains ALWAYS the airplane controlled by the pilot!
			{
				// check if aircraft is on path and angle of vision, note at index 0 is own aircraft
				for (var i = 1; i < length(aircraft_array); i++)
				{
					//calculate bearing to aircraft nearby
					var bearing_to_next_aircraft = formula.bearing(myAircraft.Get_position(), aircraft_array[i].Get_position())
					//check if bearing to next aircraft lies in between own visual sight cone
					if (formula.bearing_between_thresholds(myAircraft__heading, Taxiing__angle_of_vision, bearing_to_next_aircraft) === true)
					{
						//do some braking or set brake flags
						avoid_collision = true
					}
				}	
			}
			if (avoid_collision === true)
			{
				Taxiing_brake(0.1, 0.8)
			}
			else
			{
				if (taxi_path_points === (active_taxi_point_number + 1))
				{
					Taxiing_to_final_point()							
				}
				else
				{
					Taxiing_normal()
					// drive to next point after reaching another point
					if (distance_to_next_point < 8)
					{
						active_taxi_point_number = active_taxi_point_number + 1
					}
				}
			}	
		}
		
		
		
		if (next_action === "End_of_Actions")
		{
			go_to_next_state(state_after_taxiing)
			first_action_set = false
		}
		
		// TODO: Think about better handling and protocol for engine failure
		if (myAircraft.Get_Engine__failure() === true)
		{
			killme_info = "Engine__Failure during Taxiing"
			go_to_next_state("LeavingFrequency")
		}		
	}
	
	
	
	
	//-----Instrument Panel(IP) Functions-----
	def Check_Instrument_Engine__RPM()
	{
		//println "Checking Engine RPM via instrument"
		return myAircraft.IP_Get_Engine__RPM()
	}
	def Check_Instrument_Engine__oil_pressure()
	{
		//println "Checking Engine oil pressure instrument"
		return myAircraft.IP_Get_Engine__oil_pressure()
	}
	
	def Check_Instrument_Engine__oil_temperature()
	{
		//println "Checking Engine oil temperature instrument"
		return myAircraft.IP_Get_Engine__oil_temperature()
	}
	
	def Check_Instrument_Aircraft__true_air_speed()
	{
		//println "Checking Aircraft Speed Instrument"
		return myAircraft.IP_Get_Aircraft__true_air_speed()
	}
	
	def Check_Instrument_Aircraft__pitch()
	{
		//println "Checking Aircraft pitch via instrument"
		return myAircraft.IP_Get_Aircraft__pitch()
	}
	
	def Check_Instrument_Aircraft__rate_of_climb()
	{
		//println "Checking Aircraft climb of rate via instrument"
		return myAircraft.IP_Get_Aircraft__rate_of_climb()
	}
	
	def Check_Instrument_Aircraft__height()
	{
		//println "Checking Aircraft height via instrument"
		return myAircraft.IP_Get_Aircraft__height()
	}
	
	def Check_Instrument_RWT__fuel_quantitity()
	{
		//println "Checking RWT fuel quantity via instrument"
		return myAircraft.IP_Get_RWT__fuel_quantity()
	}
	
	def Check_Instrument_LWT__fuel_quantitity()
	{
		//println "Checking LWT fuel quantity via instrument"
		return myAircraft.IP_Get_LWT__fuel_quantity()
	}
	
	// -----Other visual, feel and acoustic function-----
	
	//TODO: Remove this function and think about another solution for taxiing, since the pilot CANT see the actual ground speed
	def Check_Visual_Aircraft__ground_speed_x()
	{
		//returns actual ground speed x
		return myAircraft.Get_Aircraft__ground_speed_x()
	}
	
	def Feel_Aircraft__acceleration_x()
	{
		// returns true if there is a forward acceleration
		if (myAircraft.Get_Aircraft__acceleration_x() > 0.2)
		{
			return true
		}
		else
		{
			return false
		}
	}
	
	def Feel_Aircraft__deceleration_x()
	{
		// returns true if there is a forward deceleration
		if (myAircraft.Get_Aircraft__acceleration_x() < -0.2)
		{
			return true
		}
		else
		{
			return false
		}
	}
	
	def Feel_Aircraft__acceleration_z()
	{
		// returns true if there is a climbing acceleration
		if (myAircraft.Get_Aircraft__acceleration_z() > 0.2)
		{
			return true
		}
		else
		{
			return false
		}
	}
	def Feel_Aircraft__deceleration_z()
	{
		// returns true if there is a falling acceleration
		if (myAircraft.Get_Aircraft__acceleration_z() < -0.2)
		{
			return true
		}
		else
		{
			return false
		}
	}
	
	def Hear_Aircraft__stall_sound()
	{
		// returns true if near or exceed stall
		return myAircraft.Get_Aircraft__stall_sound()
	}
	
	
	//-----Control_Input_Panel(CIP) Functions-----
	def Set_Aircraft__heading_bearing(input: real)
	{
		//println "Apply heading bearing " + input
		myAircraft.CIP_Set_Aircraft__heading_bearing(input)
	}
	
	def Apply_Engine__throttle(input : real)
	{
		//println "Apply throttle " + input
		myAircraft.CIP_Apply_Engine__throttle(input)
	}
	
	def Apply_Aircraft__pitch(input : real)
	{
		//println "Apply pitch (angle of attack):  " + input
		myAircraft.CIP_Apply_Aircraft__pitch(input)
	}
	
	def Set_Engine__ignition_switch(input : string)
	{
		//println "Set ignition switch to " + input
		myAircraft.CIP_Set_Engine__ignition_switch(input)
	}
	
	def Apply_Brake__deceleration(input : real)
	{
		//println "Apply Brake " + input
		myAircraft.CIP_Apply_Brake__deceleration(input)
	}
	
	def Set_Brake__parking_brake(input : string)
	{
		//println "Set Parking Brake to " + input
		myAircraft.CIP_Set_Brake__parking_brake(input)
	}
	
	def Set_Engine__mixture_control(input : string)
	{
		//println "Set Mixture Control"
		myAircraft.CIP_Set_Engine__mixture_control(input)
	}
	
	def Set_CIP__master_switch(input : string)
	{
		//println "Set Master Switch to " + input
		myAircraft.CIP_Set__master_switch(input)
	}
	
	
	
	//-----Visual Tire Functions------
	def Check_Visual_TireRightMainWheel__inflation()
	{	
		//println "Checking right Main Wheel Tire inflation"
		return myAircraft.Get_TireRightMainWheel__inflation()
	}
	
	def Check_Visual_TireLeftMainWheel__inflation()
	{	
		//println "Checking left Main Wheel Tire inflation"
		return myAircraft.Get_TireLeftMainWheel__inflation
	}
	
	def Check_Visual_TireNoseWheel__inflation()
	{	
		//println "Checking Nose Wheel Tire inflation"
		return myAircraft.Get_TireNoseWheel__inflation
	}
	
		
	//------Visual Fuel Tank Functions------
	// Note: Right - and LeftWingTank (RWT&LWT)
	def Check_Visual_RWT__fuel_quantity()
	{
		//println "Checking right wing tank fuel quantity"
		return myAircraft.Get_RWT__fuel_quantity()
	}
	
	def Check_Visual_LWT__fuel_quantity()
	{
		//println "Checking left wing tank fuel quantity"
		return myAircraft.Get_RWT__fuel_quantity()
	}
	
	def Check_Visual_RWT__water_sediments()
	{
		//println "Checking right wing tank for water sediments"
		return myAircraft.Get_RWT__water_sediments()
	}
	
	def Repair_Visual_RWT__water_sediments()
	{
		//println "Repairing right wing tank water sediments"
		myAircraft.Repair_RWT__water_sediments()
	}
	
	def Check_Visual_LWT__water_sediments()
	{
		//println "Checking left wing tank for water sediments"
		return myAircraft.Get_LWT__water_sediments()
	}
	
	def Repair_Visual_LWT__water_sediments()
	{
		//println "Repairing left wing tank water sediments"
		myAircraft.Repair_LWT__water_sediments()
	}
	
	//------Visual (or acoustic) Engine Functions------
	def Check_Visual_Engine__running()
	{
		//println "Checking Engine running"
		return myAircraft.Get_Engine__running()
	}
	
	def Check_Visual_Engine__oil()
	{
		//println "Checking Engine oil"
		return myAircraft.Get_Engine__oil()
	}
	
	def Refill_Visual_Engine__oil()
	{
		//println "Refill engine oil"
		myAircraft.Refill_Engine__oil()
	}
}





agent Aircraft on AgentLayer{
	initialize
	{
		initialize_general_values()
		initialize_AircraftCharacteristics()
		initialize_RightWingTank()
		initialize_LeftWingTank()
		initialize_Tire()
		initialize_Brake()
		initialize_Engine()
		initialize_Propeller()
		initialize_AircraftPhysics()
		initialize_CIP()
	}
	
	tick
	{
		update_general_values()
		update_Engine()
		update_LeftWingTank()
		update_RightWingTank()
		update_Brake()
		update_AircraftPhysics() // includes engine_rpm, propeller thrust, friction force
	}
	
	passive Initialize_landing(heading : real)
	{
		// quick and dirty initialization, all functions healthy and only variables that needs to differ from normal initialization
		RWT__fuel_quantity = RWT__total_capacity / 2
		RWT__water_sediments = false
		LWT__fuel_quantity = LWT__total_capacity/2
		LWT__water_sediments = false
		
		TireRightMainWheel__inflation = TireRightMainWheel__inflation_max
		TireLeftMainWheel__inflation = TireLeftMainWheel__inflation_max
		TireNoseWheel__inflation = TireNoseWheel__inflation_max
		
		Brake__parking_brake = "OFF" 
		
		Engine__oil_pump_condition = true
		Engine__oil_leakage = 0.0
		Engine__oil = Engine__oil_max
		Engine__mixture_control = "RICH"
		Engine__throttle = 0.1
		Engine__ignition_switch = "BOTH"
		Engine__running = true
		Engine__failure_probability = 0.0
		CIP__master_switch = "ON"
		
		Aircraft__true_air_speed_x = 32.0
		Aircraft__ground_speed_x = 30.0
		Aircraft__true_air_speed = 32.04
		Aircraft__height = 115
		Aircraft__flight_phase = "in-air"
		Aircraft__rate_of_climb = -1.5 // almost standard descent glide scope of 3°
		Aircraft__pitch = 3.5
		Aircraft__heading_bearing = heading
		
		// updating all values once due to calculations of several variables
		update_general_values()
		update_Engine()
		update_LeftWingTank()
		update_RightWingTank()
		update_Brake()
		update_AircraftPhysics()			
	}
	
	
	// -----General Values and Functions (Settings and Doc)-----
	observe var Latitude : real
	observe var Longitude : real
	
	//Classes and Agents
	var Utility = new UtilityClass()
	var weather : Weather
	
	//Making sure only one pilot controls the aircraft
	var occupied : bool = false
	passive Get_occupy_bool() => return occupied
	passive Set_occupied() => occupied = true
	
	passive Remove() => kill me
	passive Teleport(cor : Tuple<real, real>) => pos at cor  // TODO: Remove this workaround when bug fixed (see pilot comment)

	observe var event_info : string // maybe add something like this or think about it
	
	def initialize_general_values()
	{	
		Longitude = xcor
		Latitude = ycor
			
		event_info = "None"
		weather = nearest Weather
	}
	
	def update_general_values()
	{
		Longitude = xcor
		Latitude = ycor
	}
	
	passive Get_position() => return #(xcor, ycor) // for returning the position of the aircraft

	//-----Aircraft Characteristics-----
	observe var Aircraft__callsign : string // IDENTIFIER!
	var Aircraft__mass : real = 725.0 // kg
	var Aircraft__wing_area : real = 15.0 // m^2
	var Aircraft__wing_span : real = 10.1 // m
	var Aircraft__stall_angle : real = 14.0 // deg
	
	def Get_Aircraft__aspect_ratio() => return Aircraft__wing_span**2 / Aircraft__wing_area
	
	def initialize_AircraftCharacteristics()
	{
		Aircraft__callsign = "Cessna" + agentlayer.Get_callsign_number()
	}
	
	passive Get_callsign() => return Aircraft__callsign
	
	
	//-----Aircraft(Movement and Physics)-----
	//Note: using a geodesic coordinate system!
	observe var Aircraft__acceleration_x : real // m/s^2 with x in direction of plane heading
	observe var Aircraft__true_air_speed_x : real // m/s
	observe var Aircraft__ground_speed_x : real // m/s
	observe var Aircraft__true_air_speed : real // m/s
	var Aircraft__movement_x : real // m
	observe var Aircraft__heading_bearing : real //heading integer, usage depends on Aircraft_heading_mode
	
	observe var Aircraft__height : real // m
	observe var Aircraft__flight_phase : string // values "in-air" or "on-ground"
	observe var Aircraft__angle_of_attack : real // aerodynamic angle in degrees
	observe var Aircraft__pitch : real // value controlled by pilot in degrees, positive pitch means nose up
	observe var Aircraft__climb_angle : real // value resulting from speeds in degrees
	observe var Aircraft__lift : real // newton
	observe var Aircraft__acceleration_z : real // m/s^2 with z pointing upwards
	observe var Aircraft__rate_of_climb : real // m/s
	
	observe var Aircraft__drag : real // newton
	
	passive Get_Aircraft__acceleration_x() => return Aircraft__acceleration_x
	passive Get_Aircraft__acceleration_z() => return Aircraft__acceleration_z
	passive Get_Aircraft__ground_speed_x() => return Aircraft__ground_speed_x
	passive Get_Aircraft__stall_sound() : bool
	{
		if (Aircraft__angle_of_attack >= Aircraft__stall_angle -1)
		{
			return true
		}
		else
		{
			return false
		}
	}
	
	passive Get_Aircraft__flight_phase() => return Aircraft__flight_phase
	passive Get_Aircraft_heading_bearing() => return Aircraft__heading_bearing
	
	//lift coefficient calculation (See Excel "Calculation_Table")
	observe var Aircraft__lift_coefficient : real
	var Aircraft__lift_coefficient_slope : real = 4.9
	var Aircraft__zero_lift_angle : real 
	var Aircraft__total_stall_angle : real = 18.0 // deg, only for calculation purpose
	def Get_Aircraft__lift_coefficient()
	{
		if (Aircraft__angle_of_attack <= Aircraft__stall_angle)
		{
			Aircraft__lift_coefficient = (Aircraft__angle_of_attack - Aircraft__zero_lift_angle) * Constants.Pi / 180 * Aircraft__lift_coefficient_slope
		}
		else if (Aircraft__angle_of_attack >= Aircraft__total_stall_angle)
		{
			Aircraft__lift_coefficient = 0.0
		}
		else
		{
			Aircraft__lift_coefficient = (2 * Aircraft__stall_angle - Aircraft__angle_of_attack) * Constants.Pi / 180 * Aircraft__lift_coefficient_slope
		}
		return Aircraft__lift_coefficient
	}
	
	//drag coefficient calculation (See Excel "Calculation_Table")
	observe var Aircraft__drag_coefficient : real
	var Aircraft__zero_lift_drag_coefficient : real = 0.04
	var Aircraft__oswald_factor : real = 0.7
	def Get_Aircraft__drag_coefficient()
	{
		Aircraft__drag_coefficient = Aircraft__zero_lift_drag_coefficient + Aircraft__lift_coefficient**2 /(Aircraft__oswald_factor * Constants.Pi * Get_Aircraft__aspect_ratio())
		return	Aircraft__drag_coefficient
	}
		
		
	def initialize_AircraftPhysics()
	{
		Aircraft__acceleration_x = 0.0
		Aircraft__true_air_speed_x = 0.0
		Aircraft__ground_speed_x = 0.0
		Aircraft__true_air_speed = 0.0
		Aircraft__height = 0.0
		Aircraft__flight_phase = "on-ground"
		Aircraft__lift = 0.0
		Aircraft__acceleration_z = 0.0
		Aircraft__rate_of_climb = 0.0
		Aircraft__angle_of_attack = 0.0
		Aircraft__pitch = 0.0
		Aircraft__climb_angle = 0.0
		Aircraft__drag = 0.0
		
		Aircraft__zero_lift_angle = -3.0
	}
		
	def update_AircraftPhysics()
	{
		//Note: remember, Tick size is ONE second!
		
		// flight state
		if (Aircraft__height > 0)
		{
			Aircraft__flight_phase = "in-air"
		}
		else
		{
			Aircraft__flight_phase = "on-ground"
		}
		
		// -180° < delta_wind_bearing < 180°
		var delta_wind_bearing = ((Aircraft__heading_bearing - weather.Get_wind_bearing()) +180) % 360 - 180
		var delta_wind_bearing_rad = delta_wind_bearing * Constants.Pi / 180
		// Settings for cycle calculation
		var n_cycle = 100
		Aircraft__movement_x = 0
		
		//artificially reducing tick size here, since movement equation require smaller time intervals
		for (var i = 0; i<n_cycle; i++)
		{	
			// other components need to be updated here as well due to speed dependency!
			update_Engine_RPM()
			update_Propeller()  // thrust calculation
			update_Tire_friction_force()
			// angle calculations
			Aircraft__climb_angle = Math.Asin(Aircraft__rate_of_climb / Aircraft__true_air_speed) * 180 / Constants.Pi // for degree			
			Aircraft__angle_of_attack = (Aircraft__pitch - Aircraft__rate_of_climb)
			
			//help variable
			var Aircraft__climb_angle_rad = Aircraft__climb_angle * Constants.Pi / 180
			
			// Lift calculation - Note: True Airspeed needs to be used here!
			Aircraft__lift_coefficient = Get_Aircraft__lift_coefficient()
			Aircraft__lift = Aircraft__lift_coefficient * weather.Get_density(Aircraft__height) * Aircraft__true_air_speed**2 * Aircraft__wing_area / 2
			
			// Drag calculation
			Aircraft__drag_coefficient = Get_Aircraft__drag_coefficient()
			Aircraft__drag = Aircraft__drag_coefficient * weather.Get_density(Aircraft__height) * Aircraft__true_air_speed**2 * Aircraft__wing_area / 2
			
			//Z Movement calculation
			Aircraft__acceleration_z = ((Propeller__thrust - Tire__friction_force - Aircraft__drag) * Math.Sin(Aircraft__climb_angle_rad) + Aircraft__lift * Math.Cos(Aircraft__climb_angle_rad) - Aircraft__mass * agentlayer.Get_gravity()) / Aircraft__mass 
			Aircraft__rate_of_climb = Aircraft__rate_of_climb + Aircraft__acceleration_z / n_cycle
			Aircraft__height = Aircraft__height + Aircraft__rate_of_climb / n_cycle
			
			if (Aircraft__height < 0) //redundancy and deny negative values
			{
				Aircraft__rate_of_climb = 0
				Aircraft__height = 0
			}
			
			//X Movement calculation
			Aircraft__acceleration_x = ((Propeller__thrust - Tire__friction_force - Aircraft__drag - Brake__deceleration_force) * Math.Cos(Aircraft__climb_angle_rad) - Aircraft__lift * Math.Sin(Aircraft__climb_angle_rad)) / Aircraft__mass
			Aircraft__ground_speed_x = Aircraft__ground_speed_x + Aircraft__acceleration_x / n_cycle
			Aircraft__true_air_speed_x = Aircraft__ground_speed_x + weather.Get_wind_speed() * Math.Cos(delta_wind_bearing_rad)
			// Remove values below zero for each speed
			if (Aircraft__true_air_speed_x < 0)
			{
				Aircraft__true_air_speed_x = 0
			}
			if (Aircraft__ground_speed_x < 0)
			{
				Aircraft__ground_speed_x = 0
			}
			Aircraft__movement_x = Aircraft__movement_x + Aircraft__ground_speed_x / n_cycle
			
			// True Airspeed calculation
			Aircraft__true_air_speed = (Aircraft__true_air_speed_x**2 + Aircraft__rate_of_climb**2)**0.5
		}
		
		if (Aircraft__movement_x > 0)
		{
			move me Aircraft__movement_x to Aircraft__heading_bearing
		}
	}
		
	//-----Brake System-----
	observe var Brake__parking_brake : string // "SET" or "OFF"
	
	observe var Brake__deceleration_application : real // value No brakes applied 0...1 Full Brakes applied
	observe var Brake__deceleration_force : real // Newton
	var Brake__deceleration_force_max : real = 2500 // Newton
	
	//TODO: Add brake_health dependency on Tire inflation
	def initialize_Brake()
	{
		Brake__parking_brake = "SET" 
		Brake__deceleration_force = 0.0
		Brake__deceleration_application = 0.0
	}
	
	def update_Brake()
	{
		if (Aircraft__flight_phase === "on-ground")
		{
			Brake__deceleration_force = Brake__deceleration_application * Brake__deceleration_force_max
			if (Brake__parking_brake === "SET")
			{
				Brake__deceleration_force = Brake__deceleration_force_max
			}
		}
		
		else
		{
			Brake__deceleration_force = 0
		}
	}
	
	
	// -----Propeller-----
	var Propeller__diameter : real = 1.75 // meters
	observe var Propeller__thrust : real // newton
	
	// Thrust Coefficient (See Excel "Calculation Table")
	observe var Propeller__thrust_coefficient : real
	var Propeller__thrust_coefficient_slope : real // has to be initialized, since negative and Mars does not allow direct negative number assignment
	var Propeller__thrust_coefficient_constant : real = 0.1
	var Propeller__thrust_coefficient_speed_constant : real = 25.0 //Up to which speed coefficient is constant
	def Get_Propeller__thrust_coefficient()
	{
		if (Aircraft__true_air_speed > Propeller__thrust_coefficient_speed_constant)
		{
			Propeller__thrust_coefficient = Propeller__thrust_coefficient_slope * (Aircraft__true_air_speed - Propeller__thrust_coefficient_speed_constant) + Propeller__thrust_coefficient_constant
		}
		else
		{
			Propeller__thrust_coefficient = Propeller__thrust_coefficient_constant
		}
		
		if (Propeller__thrust_coefficient < 0)
		{
			Propeller__thrust_coefficient = 0
		}
		return Propeller__thrust_coefficient
	}
	
	
	def initialize_Propeller()
	{
		Propeller__thrust = 0.0
		
		Propeller__thrust_coefficient_slope = -0.002
	}
	
	def update_Propeller()
	{
		// Propeller thrust calculation
		Propeller__thrust_coefficient = Get_Propeller__thrust_coefficient()
		Propeller__thrust = Propeller__thrust_coefficient * weather.Get_density(Aircraft__height) * (Engine__RPM/60)**2 * Propeller__diameter**4
	}
	
	// -----Engine-----
	observe var Engine__oil : real  // litre
	observe var Engine__oil_pressure : real // normal between 205000 and 410000 Pa
	observe var Engine__oil_temperature : real // normal between 38°C and 116°C
	observe var Engine__mixture_control : string  // either "RICH" or "LEAN"
	observe var Engine__throttle : real  // percentage NO THROTTLE 0..1 FULL THROTTLE
	observe var Engine__power : real // between 0W and 75000W 
	observe var Engine__ignition_switch : string  // "OFF", "BOTH" or "START" (not used so far: "L", "R")
	observe var Engine__RPM : real  //calculated via formula with power coefficient
	observe var Engine__running : bool
	observe var Engine__failure_probability : real // percentage per tick 0..1
	observe var Engine__failure : bool
	observe var Engine__fuel_consumption : real // liters/s
	observe var Engine__oil_pump_condition : bool // either true (healthy) or false (faulty)
	observe var Engine__oil_leakage : real // either 0 or low value
	
	//Power Coefficient (See Excel "Calculation Table")
	//Note: assumption cp = f(V/(n*d)) with n*d=1
	var Engine__power_coefficient : real
	var Engine__power_coefficient_slope : real // has to be initialized, since negative and Mars does not allow direct negative number assignment
	var Engine__power_coefficient_constant : real = 0.05
	var Engine__power_coefficient_speed_constant : real = 30.0 //Up to which speed coefficient is constant
	
	def Get_Engine__power_coefficient()
	{
		if (Aircraft__true_air_speed > Engine__power_coefficient_speed_constant)
		{
			Engine__power_coefficient = Engine__power_coefficient_slope * (Aircraft__true_air_speed - Engine__power_coefficient_speed_constant) + Engine__power_coefficient_constant
		}
		else
		{
			Engine__power_coefficient = Engine__power_coefficient_constant
		}
		return Engine__power_coefficient
	}

	//Settings
	var Engine__oil_max : integer = 6
	var Engine__oil_min : integer = 4
	var Engine__oil_critical_min : integer = 3
	var Engine__oil_pressure_normal_min = 205000
	var Engine__oil_pressure_normal_max = 410000
	var Engine__oil_temperature_normal_min = 38 // normal value, but higher one would be better for linear assumption in calculation later
	var Engine__oil_temperature_normal_max = 116
	var Engine__RPM_max : integer = 2750
	var Engine__power_max : integer = 75000 // W
	var Engine__fuel_consumption_max : real = 0.0079 // liters/s (correspond to 7.5 gallon per hour)
	
	passive Get_Engine__oil_min() => return Engine__oil_min
	passive Get_Engine__oil_temperature_normal_max() => return Engine__oil_temperature_normal_max
	passive Get_Engine__oil_pressure_normal_min() => return Engine__oil_pressure_normal_min
	
	// TODO: Help function as long as handling for TakeOff and Taxi is being difficult
	passive Get_Engine__failure() => return Engine__failure
	
	def initialize_Engine()
	{
		Engine__oil_pump_condition = Utility.probability_check(0.98) // either true (98%) or false
		Engine__oil_leakage = 0.0
		if (Utility.probability_check(0.02) === true)
		{
			Engine__oil_leakage = 0.01
		}
		Engine__oil = 3.1 + random(3) + (random(10) / 10.0)
		Engine__mixture_control = #["LEAN", "RICH"].Get(random(2))
		Engine__throttle = random(10) / 10.0
		Engine__ignition_switch = "OFF"
		Engine__RPM = 0.0
		Engine__power = 0.0
		Engine__running = false
		Engine__oil_pressure = 101325
		Engine__oil_temperature = weather.Get_temperature()
		Engine__failure_probability = 0.0
		Engine__failure = false
		Engine__fuel_consumption = 0.0
		
		Engine__power_coefficient_slope = -0.0009	
	}
	
	
	def Set_Engine__not_running_values()
	{
		Engine__running = false
		Engine__RPM = 0.0
		Engine__power = 0.0
		Engine__oil_pressure = 101325
		Engine__oil_temperature = 15
		Engine__fuel_consumption = 0.0
	}
	
	def Add_Engine__failure_probability(add : real) => Engine__failure_probability = Engine__failure_probability + add
	def Calculate_Engine__failure_probability()
	{
		Engine__failure_probability = 0.0
		if (RWT__water_sediments === true)
		{
			Add_Engine__failure_probability(10**(-4))
		}
		if (LWT__water_sediments === true)
		{
			Add_Engine__failure_probability(10**(-4))
		}
		if (Engine__oil < Engine__oil_min)
		{
			Add_Engine__failure_probability(5 * 10**(-4))
		}
		if (Engine__oil < Engine__oil_critical_min)
		{
			Add_Engine__failure_probability(5 * 10**(-2))
		}
		if (Engine__oil_pump_condition === false)
		{
			Add_Engine__failure_probability(5 * 10**(-4))
		}
		if (Engine__mixture_control === "LEAN")
		{
			Add_Engine__failure_probability(10**(-4))
		}
	}
	
	// used in aircraft physics directly
	def update_Engine_RPM()
	{
		//Engine RPM Calculation
		Engine__power_coefficient = Get_Engine__power_coefficient()
		Engine__RPM = (Engine__power/(Engine__power_coefficient*weather.Get_density(Aircraft__height)*Propeller__diameter**5))**0.3333 * 60 // FACTOR 60 TO CONVERT INTO PER MINUTE
		if (Engine__RPM > Engine__RPM_max)
		{
			Engine__RPM = Engine__RPM_max
		}
	}
	
	def update_Engine()
	{
		if (Engine__running === false or Engine__failure === true)
		{
			Set_Engine__not_running_values()
			if (Engine__ignition_switch === "START" and CIP__master_switch === "ON" and Engine__failure === false)
			{
				if (random(100) <= 40) // 40% chance for engine to start
				{
					//println "The engine started successfully."
					Engine__running = true
				}
			}
		}
		
		if (Engine__running === true and Engine__failure === false)
		{
			//Engine Power Calculation
			Engine__power = Engine__power_max * Engine__throttle
			if (Engine__mixture_control === "LEAN")
			{
				Engine__power = Engine__power - Engine__power * 0.1 // simulating power loss due to wrong settings during on ground
			}
			
			// Engine Failure Probability
			Calculate_Engine__failure_probability()
			if (Utility.probability_check(Engine__failure_probability) === true)
			{
				event_info = "Engine Failure"
				Engine__failure = true
			}
			
			// Engine turned off
			if (Engine__ignition_switch === "OFF" or CIP__master_switch === "OFF")
			{
				Engine__running = false
			}
			
			// Engine fuel_consumption
			Engine__fuel_consumption = Engine__fuel_consumption_max * Engine__throttle 
			
			//Engine Oil
			Engine__oil = Engine__oil - Engine__oil_leakage
			var Engine__oil_temperature_slope = (Engine__oil_temperature_normal_min - Engine__oil_temperature_normal_max) / (Engine__oil_max - Engine__oil_min)
			var Engine__oil_pressure_slope = (Engine__oil_pressure_normal_max - Engine__oil_pressure_normal_min) / (Engine__oil_max - Engine__oil_min)
			Engine__oil_pressure = (Engine__oil_pressure_normal_min - Engine__oil_pressure_slope * Engine__oil_min) + Engine__oil_pressure_slope * Engine__oil
			Engine__oil_temperature = (Engine__oil_temperature_normal_max - Engine__oil_temperature_slope * Engine__oil_min) + Engine__oil_temperature_slope * Engine__oil
			if (Engine__oil_pump_condition === false)
			{
				// simulating faulty engine pump values
				Engine__oil_temperature = Engine__oil_temperature + (Engine__oil_temperature_normal_max - Engine__oil_temperature_normal_min)/2
				Engine__oil_pressure = Engine__oil_pressure - (Engine__oil_pressure_normal_max - Engine__oil_pressure_normal_min)/2
			}
			if (Engine__oil_pressure < 101325)
			{
				Engine__oil_pressure = 101325
			}
		}
	}
	
	passive Get_Engine__running() => return Engine__running
	passive Get_Engine__oil() => return Engine__oil
	passive Refill_Engine__oil() => Engine__oil = Engine__oil_max
	
	
	
	// -----Right Wing Tank (RWT)-----
	// Note: Right - and LeftWingTank (RWT&LWT)
	observe var RWT__fuel_quantity : real 
	observe var RWT__water_sediments : bool
	var RWT__total_capacity : integer = 49 // Litre
		
	passive Get_RWT__fuel_quantity() => return RWT__fuel_quantity
	passive Get_RWT__water_sediments() => return RWT__water_sediments
	passive Repair_RWT__water_sediments() => RWT__water_sediments = false
	
	def initialize_RightWingTank()
	{
		RWT__fuel_quantity = random(RWT__total_capacity+1)
		RWT__water_sediments = Utility.probability_check(0.5) // either true or false
	}
	
	def update_RightWingTank()
	{
		RWT__fuel_quantity = RWT__fuel_quantity - Engine__fuel_consumption/2 //half to each tank
	}
	
	// -----Left Wing Tank (LWT)-----
	observe var LWT__fuel_quantity : real // Litre
	observe var LWT__water_sediments : bool
	var LWT__total_capacity : integer = 49 // Litre
	
	passive Get_LWT__fuel_quantity() => return LWT__fuel_quantity // return of fuel quantity "visual"
	passive Get_LWT__water_sediments() => return LWT__water_sediments
	passive Repair_LWT__water_sediments() => LWT__water_sediments = false
	
	def initialize_LeftWingTank()
	{
		LWT__fuel_quantity = random(LWT__total_capacity+1)
		LWT__water_sediments = Utility.probability_check(0.5) // either true or false
	}
	
	def update_LeftWingTank()
	{
		LWT__fuel_quantity = LWT__fuel_quantity - Engine__fuel_consumption/2 //half to each tank
	}	
	
	
	// -----Tire-----
	var TireRightMainWheel__inflation : integer
	var TireLeftMainWheel__inflation : integer
	var TireNoseWheel__inflation : integer
	var TireRightMainWheel__inflation_max : integer = 145000
	var TireLeftMainWheel__inflation_max : integer = 145000
	var TireNoseWheel__inflation_max : integer = 207000
	var Tire__number_of_wheels : integer = 3
	var Tire__wheel_radius : real = 0.075 //meter; neglecting non equal size of nose and main wheels
	
	// Friction Calculation (See Excel "Calculation table")
	observe var Tire__friction_force : real //newton
	var Tire__roll_coefficient : real = 0.002 //meters
	
	def initialize_Tire()
	{
		TireRightMainWheel__inflation = TireRightMainWheel__inflation_max
		TireLeftMainWheel__inflation = TireLeftMainWheel__inflation_max
		TireNoseWheel__inflation = TireNoseWheel__inflation_max
		Tire__friction_force = 0
	}
	
	//TODO: Add Tire condition dependencies and then user other initialize
	def initialize_Tire_alternative()
	{
		//Inflation with 1% Chance that a Tire is not fully inflated
		if (random(100) <= 99)
		{
			TireRightMainWheel__inflation = TireRightMainWheel__inflation_max
		}
		else
		{
			TireRightMainWheel__inflation = random(TireRightMainWheel__inflation_max)
		}
		
		if (random(100) <= 99)
		{
			TireLeftMainWheel__inflation = TireLeftMainWheel__inflation_max
		}
		else
		{
			TireLeftMainWheel__inflation = random(TireLeftMainWheel__inflation_max)
		}
		
		if (random(100) <= 99)
		{
			TireNoseWheel__inflation = TireNoseWheel__inflation_max
		}
		else
		{
			TireNoseWheel__inflation = random(TireNoseWheel__inflation_max)
		}
		
		Tire__friction_force = 0
	}
	
	// used in aircraft physics directly
	def update_Tire_friction_force()
	{
		//TODO: Add friction dependency on Tire inflation
		if (Aircraft__flight_phase === "on-ground")
		{
			Tire__friction_force = (Aircraft__mass * agentlayer.Get_gravity() - Aircraft__lift) * Tire__number_of_wheels * Tire__roll_coefficient / Tire__wheel_radius
		}
		else
		{
			Tire__friction_force = 0
		}
		
		if (Tire__friction_force < 0)
		{
			Tire__friction_force = 0
		}		
	}
	
	passive Get_TireRightMainWheel__inflation() => return TireRightMainWheel__inflation
	passive Get_TireLeftMainWheel__inflation() => return TireLeftMainWheel__inflation
	passive Get_TireNoseWheel__inflation() => return TireNoseWheel__inflation
	
	
	
	//-----Control_Input_Panel(CIP)-----
	// Interface for pilot input when sitting in Aircraft for giving Input
	
	// master switch here, since placing in other classes difficult
	observe var CIP__master_switch : string // "ON" or "OFF"
	
	def initialize_CIP()
	{
		CIP__master_switch = "OFF" 
	}
	
	passive CIP_Set_Engine__ignition_switch(input : string)
	{
		Engine__ignition_switch = input
	}

	passive CIP_Apply_Engine__throttle(input: real)
	{
		Engine__throttle = input
		
		// redundancy
		if (Engine__throttle < 0)
		{
			Engine__throttle = 0
		}
		else if (Engine__throttle > 1)
		{
			Engine__throttle = 1
		}
	}
	
	//Both function works as heading input, since calculation for heading within pilot not yet integrated
	passive CIP_Set_Aircraft__heading_bearing(input : real)
	{
		Aircraft__heading_bearing = input
	}
	
	passive CIP_Apply_Aircraft__pitch(input : real)
	{
		Aircraft__pitch = input
	}
	
	passive CIP_Set__master_switch(input: string)
	{
		CIP__master_switch = input
	}	
	
	passive CIP_Set_Brake__parking_brake(input : string)
	{
		Brake__parking_brake = input
	}
	
	passive CIP_Apply_Brake__deceleration(input : real)
	{
		Brake__deceleration_application = input
	}
	
	passive CIP_Set_Engine__mixture_control(input : string)
	{
		Engine__mixture_control = input
	}
	
	
	
	//-----Instrument_Panel(IP)-----
	// Interface for pilot input when sitting in Aircraft for reading Instruments
	
	passive IP_Get_Engine__oil_pressure()
	{
		return Engine__oil_pressure()
	}
	
	passive IP_Get_Engine__oil_temperature()
	{
		return Engine__oil_temperature()
	}
	
	//airspeed_indicator
	passive IP_Get_Aircraft__true_air_speed()
	{
		return Aircraft__true_air_speed
	}
	
	//artificial_horizon
	passive IP_Get_Aircraft__pitch()
	{
		return Aircraft__pitch
	}
	
	//vertival speed indicator
	passive IP_Get_Aircraft__rate_of_climb()
	{
		return Aircraft__rate_of_climb
	}
	
	//altimeter
	passive IP_Get_Aircraft__height()
	{
		return Aircraft__height
	}
	
	//fuel indicator
	passive IP_Get_RWT__fuel_quantity()
	{
		return RWT__fuel_quantity
	}
	passive IP_Get_LWT__fuel_quantity()
	{
		return LWT__fuel_quantity
	}
	
	//tachometer
	passive IP_Get_Engine__RPM()
	{
		return Engine__RPM
	}
}


//-----Agent AirTrafficController sitting in tower and answering requests-----
agent AirTrafficController on AgentLayer
	{	
		initialize
		{
			initialize_general_values()	
			var x_spawn = 9.501334
			var y_spawn = 53.559712
			pos at #(x_spawn, y_spawn)
			request_approval = false
			available_runway_heading = airportstade.Get_available_runway_heading_list()
		}
		
		tick
		{
			weather = nearest Weather // Has do be done here, since during initialization Weather agent might not be existing yet
			
			if (state === "Listen_on_frequency")
			{
				timehandler.create_action_duration(2, 2, "None")
				if (timehandler.hold_action_time(timehandler.action_duration))
				{
					var temp_receiver = agentlayer.Listen_receiver_on_frequency()
					if (temp_receiver === identifier)
					{
						state = "Communicate_on_frequency"
						message_type_received = agentlayer.Listen_message_type_on_frequency()
						callsign_received = agentlayer.Listen_sender_identifier_on_frequency()
					}
				}
			}
			
			else if (state === "Communicate_on_frequency")
			{
				timehandler.create_action_duration(2, 2, "None")
				if (timehandler.hold_action_time(timehandler.action_duration))
				{
					//Calculation of runway heading
					//Initialization of calculation
					var wind_bearing = weather.Get_wind_bearing()
					runway_heading_calculated = formula.calculate_runway_heading(available_runway_heading, wind_bearing)
					
					if (message_type_received === "RequestTakeOffPreparationPoint")
					{
						taxipath = airportstade.Get_taxipath_to_TakeOffPreparationPoint(runway_heading_calculated)
						agentlayer.Communicate_answer_on_frequency(identifier, callsign_received, "AnswerTakeOffPreparationPoint", taxipath, runway_heading_calculated, request_approval)
					}
					else if(message_type_received === "RequestTakeOffHoldShortPoint")
					{
						taxipath = airportstade.Get_taxipath_to_RunwayHoldShortPoint(runway_heading_calculated)
						agentlayer.Communicate_answer_on_frequency(identifier, callsign_received, "AnswerTakeOffHoldShortPoint", taxipath, runway_heading_calculated, request_approval)
					}
					else if(message_type_received === "RequestTakeOff")
					{
						taxipath = airportstade.Get_taxipath_to_RunwayLineUpPoint(runway_heading_calculated)
						var pilot_array = explore Pilot where [x => return x.Get_state() === "Landing" or x.Get_state() === "TakeOff"]
						if (length(pilot_array) >= 1) // active aircraft on runway
						{
							request_approval = false
						}
						else
						{
							request_approval = true
						}
						agentlayer.Communicate_answer_on_frequency(identifier, callsign_received, "AnswerTakeOff", taxipath, runway_heading_calculated, request_approval)
					}
					else if(message_type_received === "RequestLanding")
					{
						taxipath = airportstade.Get_taxipath_to_ApronPoint(runway_heading_calculated)
						var pilot_array = explore Pilot where [x => return x.Get_state() === "TakeOff"]
						if (length(pilot_array) >= 1) // active aircraft on runway
						{
							request_approval = false
						}
						else
						{
							request_approval = true
						}
						agentlayer.Communicate_answer_on_frequency(identifier, callsign_received, "AnswerLanding", taxipath, runway_heading_calculated, request_approval)
					}
					else if(message_type_received === "RequestLeavingAirpsace")
					{
						request_approval = true // always true so far
						agentlayer.Communicate_answer_on_frequency(identifier, callsign_received, "AnswerRequestAirspace", taxipath, runway_heading_calculated, request_approval)
					}
					else
					{
						agentlayer.Clear_frequency() // Tower always able to answer or Clear Frequency, when request insufficient		
					}
					reset_general_values()
					
				}
			}
		}
		
		//-----General Values and functions (Settings)-----
		observe var identifier : string  // only Tower ATC so far
		observe var state : string
		observe var message_type_received : string
		observe var callsign_received : string
		observe var runway_heading_calculated : real
		var timehandler = new TimeHandler()
		var airportstade = new AirportStade() // for airport information retrieval
		var taxipath : List<Tuple<real, real>>
		var request_approval : bool // either true or false for answering
		var available_runway_heading : List<real>
		var formula = new Formula()
		var weather : Weather
		
		def initialize_general_values()
		{
			identifier = "Tower"
			state = "Listen_on_frequency"
			callsign_received = "None"
			message_type_received = "None"
			
		}
		
		def reset_general_values()
		{
			state = "Listen_on_frequency"
			callsign_received = "None"
			message_type_received = "None"
		}
		
	}



// TODO: Make a more convenient way for information retrieval of airport (graph based system, ...)
class AirportStade
{
	var taxipath: List<Tuple<real, real>>
	var available_runway_heading_list = #[110.0, 290.0]
	
	def Get_available_runway_heading_list() => return available_runway_heading_list
	
	def Get_taxipath_to_TakeOffPreparationPoint(heading : real)
	{
		if (heading === available_runway_heading_list.Get(0))
		{
			taxipath = #[#(9.4994287,53.5604441), #(9.4934248,53.5617509), #(9.4931937,53.5618008), #(9.4930632,53.5618664)]
			return taxipath
		}
		
		else if (heading === available_runway_heading_list.Get(1))
		{
			taxipath = #[#(9.4994287,53.5604441), #(9.5010603,53.5600816), #(9.5018283,53.559911), #(9.5041687,53.5594248), #(9.5043157,53.5594584)]
			return taxipath
		}
	}
	
	def Get_taxipath_to_RunwayHoldShortPoint(heading: real)
	{
		if (heading === available_runway_heading_list.Get(0))
		{
			taxipath = #[#(9.4930261,53.5619488),#(9.4930903,53.5620665),#(9.4932789,53.5621333), #(9.4939417,53.562171)]
			return taxipath
		}
		
		else if (heading === available_runway_heading_list.Get(1))
		{
			taxipath = #[#(9.5044877,53.5595613), #(9.5046714,53.5597239)]
			return taxipath
		}
	}
	
	def Get_taxipath_to_RunwayLineUpPoint(heading: real)
	{
		if (heading === available_runway_heading_list.Get(0))
		{
			taxipath = #[#(9.494201,53.5621611), #(9.494446,53.5621252)]
			return taxipath
		}
		
		else if (heading === available_runway_heading_list.Get(1))
		{
			taxipath = #[#(9.5048527,53.5598626), #(9.5028175,53.5603097)]
			return taxipath
		}
	}
	
	def Get_taxipath_to_ApronPoint(heading: real)
	{
		if (heading === available_runway_heading_list.Get(0))
		{
			taxipath = #[#(9.5028175,53.5603097), #(9.5048527,53.5598626), #(9.5046714,53.5597239), #(9.5044877,53.5595613), #(9.5043157,53.5594584), #(9.5041687,53.5594248), #(9.5018283,53.559911)]
			return taxipath
		}
		else if (heading === available_runway_heading_list.Get(1))
		{
			taxipath = #[#(9.494446,53.5621252), #(9.494201,53.5621611), #(9.4939417,53.562171),#(9.4932789,53.5621333),#(9.4930903,53.5620665),#(9.4930261,53.5619488), #(9.4930632,53.5618664), #(9.4931937,53.5618008), #(9.4934248,53.5617509), #(9.498464,53.560657)]
			return taxipath
		}
	}	
	
	def Get_landing_spawning_point(heading: real)
	{
		if (heading === available_runway_heading_list.Get(0))
		{
			return #(9.467238,53.567997)
		}
		
		else if (heading === available_runway_heading_list.Get(1))
		{
			return #(9.530016,53.554431)
		}
	}
	
	def Get_left_apron_coordinates()
	{
		return #(9.4987928, 53.560392)
	}
	def Get_right_apron_coordinates()
	{
		return #(9.5009108, 53.5599218)
	}
	
	
}

// -----Class with helper functions-----
class Formula
{
	def haversine(point1 : Tuple<real, real>, point2: Tuple<real, real>)
	{
		//Returns the distance between two points
		//Note: Math functions in Mars are using RADIANS [rad]
		//Input assumed: In GeoJson and Mars the order is (Lon[°], Lat[°])!
		var deg_to_rad_factor = Constants.Pi / 180
		var lon1 = point1.Item1() * deg_to_rad_factor
		var lat1 = point1.Item2() * deg_to_rad_factor
		var lon2 = point2.Item1() * deg_to_rad_factor
		var lat2 = point2.Item2() * deg_to_rad_factor
		
		var dlon = lon2 - lon1
		var dlat = lat2 - lat1
		
		//Workaround, since some problems with type appeared
		//a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
		var summand1 : real = (Math.Sin(dlat/2))**2
		var factor1 : real = Math.Cos(lat1)
		var factor2 : real = Math.Cos(lat2)
		var factor3 : real = (Math.Sin(dlon/2))**2
		var a = summand1 + (factor1 * factor2 * factor3)	
		
		//c = 2 * asin(sqrt(a)) 
		var c : real = 2 * Math.Atan2(a**0.5, (1-a)**0.5)
		var r = 6371000 //Radius of earth in meters
		
	    return c*r
		                                                                 
	}
	
	def bearing(point1 : Tuple<real, real>, point2: Tuple<real, real>)
	{
		// returns the bearing from point 1 TO point 2
		//Note: Math functions in Mars are using RADIANS [rad]
		//Input assumed: In GeoJson and Mars the order is (Lon[°], Lat[°])!
		var deg_to_rad_factor = Constants.Pi / 180
		var rad_to_deg_factor = 180 / Constants.Pi
		var lon1 = point1.Item1() * deg_to_rad_factor
		var lat1 = point1.Item2() * deg_to_rad_factor
		var lon2 = point2.Item1() * deg_to_rad_factor
		var lat2 = point2.Item2() * deg_to_rad_factor
		
		var dlon = lon2 - lon1
		
		//Workaround, since some problems with type appeared
		// bearing = atan2(sin(dlon) * cos(lat2), cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dlon))
		var y : real = Math.Sin(dlon) * Math.Cos(lat2)
		var x1 : real = Math.Cos(lat1) * Math.Sin(lat2)
		var x2: real = Math.Sin(lat1) * Math.Cos(lat2)
		var x3 : real = Math.Cos(dlon)
		var x : real = x1 - x2 * x3
		
		var bearing : real = Math.Atan2(y, x) * rad_to_deg_factor
		bearing = (bearing + 360) % 360
		return bearing
	}
	
	def bearing_between_thresholds(cone_bearing : real, cone_angle : real, check_bearing : real)
	{
		// returns true, if a checked heading lies in between a cone
		var delta = smallest_absolute_delta(cone_bearing, check_bearing)
		if (delta <= cone_angle/2)
		{
			return true
		}
		else
		{
			return false
		}
	}
	
	def smallest_absolute_delta(a1 : real, a2: real)
	{
		//returns the smallest delta between 0..180 from two points in range from 0..360°
		var delta = 180 - Math.Abs(Math.Abs(a1 - a2)- 180)
		return delta
	}
	
	def calculate_runway_heading(available_runway_heading : List<real>, wind_bearing : real)
	{
		var temp_delta = 999.9 // this will be always overwritten
		var saved_heading : real
		//Looping through all available headings
		each (var temp_runway_heading in available_runway_heading)
		{
			if (smallest_absolute_delta(temp_runway_heading, wind_bearing)< temp_delta)
			{
				saved_heading = temp_runway_heading
				temp_delta = smallest_absolute_delta(temp_runway_heading, wind_bearing)
			}
		}
		return saved_heading
	}
}

// -----Class for handling all time issues-----
class TimeHandler
{
	//general values for timehandling
	var action_run_time : real =  0
	var action_duration_time_set : bool = false
	var action_duration : real
	
	// pilot characteristics for time calculations
	var pilot_age : real
	var pilot_flight_experience: real
	var pilot_flight_experience_max : real
	var pilot_age_max : real
	var pilot_age_min : real
	
	def initialize_variables
	(
		p_age : real, 
		p_exp : real,
		p_exp_max : real,
		p_age_max : real,
		p_age_min : real
		
	)
	{
		pilot_age = p_age
		pilot_flight_experience = p_exp
		pilot_flight_experience_max = p_exp_max
		pilot_age_max = p_age_max
		pilot_age_min = p_age_min
	}
	
	def hold_action_time(time_needed : real): bool 
	{
		action_run_time = action_run_time + 1
		if (action_run_time >= time_needed)
		{
			reset_action_timer()
			action_duration_time_set = false
			return true	
		}
		else
		{
			return false
		}
	}
	
	def reset_action_timer(): void
	{
		action_run_time = 0
	}
	
	def create_action_duration(action_duration_base : real, action_duration_extra : real, mode : string)
	{
		if (action_duration_time_set === false)
		{
			action_duration_time_set = true			
			if (mode === "pilot_age_and_experience")
			{
				var action_duration_extra_calc = action_duration_extra * (1 + (pilot_age / pilot_age_max) - pilot_flight_experience / (pilot_flight_experience_max) )
				action_duration = action_duration_base + random(action_duration_extra_calc)
			}
			else
			{
				action_duration = action_duration_base + random(action_duration_extra)
			}				
		}
	}
}

class UtilityClass
{
	def probability_check(probability : real) : bool
	// Probability Checker for events with a precision of 10^6
	{
		var random_value = random(10**6)/10**6
		if (random_value >= probability)
		{
			return false
		}
		else
		{
			return true
		}
	}
}



