model cessna_digital_twin

use Mars

agent Aircraft on AgentLayer{
	initialize
	{
		initialize_general_values()
		initialize_AircraftCharacteristics()
		initialize_RightWingTank()
		initialize_LeftWingTank()
		initialize_Tire()
		initialize_Brake()
		initialize_Engine()
		initialize_Propeller()
		initialize_AircraftPhysics()
		initialize_CIP()
	}
	
	tick
	{
		update_general_values()
		update_Engine()
		update_LeftWingTank()
		update_RightWingTank()
		update_Brake()
		update_AircraftPhysics() // includes engine_rpm, propeller thrust, friction force
	}
	
	
	
	// -----General Values and Functions (Settings and Doc)-----
	observe var Latitude : real
	observe var Longitude : real
	
	//Classes
	var Utility = new UtilityClass()
	
	//Making sure only one pilot controls the aircraft
	var occupied : bool = false
	passive Get_occupy_bool() => return occupied
	passive Set_occupied() => occupied = true
	
	passive Remove() => kill me

	observe var event_info : string // maybe add something like this or think about it
	
	def initialize_general_values()
	{
		var x_spawn = agentlayer.Get_spawn_x_coord()
		var y_spawn = agentlayer.Get_spawn_y_coord()
		pos at #(x_spawn, y_spawn)
		
		Longitude = xcor
		Latitude = ycor
		
		event_info = "None"
	}
	
	def update_general_values()
	{
		Longitude = xcor
		Latitude = ycor
	}
	
	passive Get_position() => return #(xcor, ycor) // for returning the position of the aircraft
	
	
	//-----Aircraft Characteristics-----
	observe var Aircraft__callsign : string // IDENTIFIER!
	var Aircraft__mass : real = 725.0 // kg
	var Aircraft__wing_area : real = 15.0 // m^2
	var Aircraft__wing_span : real = 10.1 // m
	var Aircraft__stall_angle : real = 14.0 // deg
	
	def Get_Aircraft__aspect_ratio() => return Aircraft__wing_span**2 / Aircraft__wing_area
	
	def initialize_AircraftCharacteristics()
	{
		Aircraft__callsign = "Cessna" + agentlayer.Get_callsign_number()
	}
	
	passive Get_callsign() => return Aircraft__callsign
	
	
	//-----Aircraft(Movement and Physics)-----
	//Note: using a geodesic coordinate system!
	observe var Aircraft__acceleration_x : real // m/s^2 with x in direction of plane heading
	observe var Aircraft__true_air_speed_x : real // m/s
	observe var Aircraft__ground_speed_x : real // m/s
	observe var Aircraft__true_air_speed : real // m/s
	var Aircraft__movement_x : real // m
	observe var Aircraft__heading_bearing : real //heading integer, usage depends on Aircraft_heading_mode
	
	observe var Aircraft__height : real // m
	observe var Aircraft__flight_phase : string // values "in-air" or "on-ground"
	observe var Aircraft__angle_of_attack : real // aerodynamic angle in degrees
	observe var Aircraft__pitch : real // value controlled by pilot in degrees, positive pitch means nose up
	observe var Aircraft__climb_angle : real // value resulting from speeds in degrees
	observe var Aircraft__lift : real // newton
	observe var Aircraft__acceleration_z : real // m/s^2 with z pointing upwards
	observe var Aircraft__rate_of_climb : real // m/s
	
	observe var Aircraft__drag : real // newton
	
	passive Get_Aircraft__acceleration_x() => return Aircraft__acceleration_x
	passive Get_Aircraft__acceleration_z() => return Aircraft__acceleration_z
	passive Get_Aircraft__ground_speed_x() => return Aircraft__ground_speed_x
	passive Get_Aircraft__stall_sound() : bool
	{
		if (Aircraft__angle_of_attack >= Aircraft__stall_angle -1)
		{
			return true
		}
		else
		{
			return false
		}
	}
	
	//lift coefficient calculation (See Excel "Calculation_Table")
	observe var Aircraft__lift_coefficient : real
	var Aircraft__lift_coefficient_slope : real = 4.9
	var Aircraft__zero_lift_angle : real 
	var Aircraft__total_stall_angle : real = 18.0 // deg, only for calculation purpose
	def Get_Aircraft__lift_coefficient()
	{
		if (Aircraft__angle_of_attack <= Aircraft__stall_angle)
		{
			Aircraft__lift_coefficient = (Aircraft__angle_of_attack - Aircraft__zero_lift_angle) * Constants.Pi / 180 * Aircraft__lift_coefficient_slope
		}
		else if (Aircraft__angle_of_attack >= Aircraft__total_stall_angle)
		{
			Aircraft__lift_coefficient = 0.0
		}
		else
		{
			Aircraft__lift_coefficient = (2 * Aircraft__stall_angle - Aircraft__angle_of_attack) * Constants.Pi / 180 * Aircraft__lift_coefficient_slope
		}
		return Aircraft__lift_coefficient
	}
	
	//drag coefficient calculation (See Excel "Calculation_Table")
	observe var Aircraft__drag_coefficient : real
	var Aircraft__zero_lift_drag_coefficient : real = 0.04
	var Aircraft__oswald_factor : real = 0.7
	def Get_Aircraft__drag_coefficient()
	{
		Aircraft__drag_coefficient = Aircraft__zero_lift_drag_coefficient + Aircraft__lift_coefficient**2 /(Aircraft__oswald_factor * Constants.Pi * Get_Aircraft__aspect_ratio())
		return	Aircraft__drag_coefficient
	}
		
		
	def initialize_AircraftPhysics()
	{
		Aircraft__acceleration_x = 0.0
		Aircraft__true_air_speed_x = 0.0
		Aircraft__true_air_speed = 0.0
		Aircraft__height = 0.0
		Aircraft__flight_phase = "on-ground"
		Aircraft__lift = 0.0
		Aircraft__acceleration_z = 0.0
		Aircraft__rate_of_climb = 0.0
		Aircraft__angle_of_attack = 0.0
		Aircraft__pitch = 0.0
		Aircraft__climb_angle = 0.0
		Aircraft__drag = 0.0
		
		Aircraft__zero_lift_angle = -3.0
	}
		
	def update_AircraftPhysics()
	{
		//Note: remember, Tick size is ONE second!
		
		// flight state
		if (Aircraft__height > 0)
		{
			Aircraft__flight_phase = "in-air"
		}
		else
		{
			Aircraft__flight_phase = "on-ground"
		}
		
		// -180째 < delta_wind_bearing < 180째
		var delta_wind_bearing = ((Aircraft__heading_bearing - agentlayer.Get_Weather__wind_bearing()) +180) % 360 - 180
		var delta_wind_bearing_rad = delta_wind_bearing * Constants.Pi / 180
		// Settings for cycle calculation
		var n_cycle = 100
		Aircraft__movement_x = 0
		
		//artificially reducing tick size here, since movement equation require smaller time intervals
		for (var i = 0; i<n_cycle; i++)
		{	
			// other components need to be updated here as well due to speed dependency!
			update_Engine_RPM()
			update_Propeller()  // thrust calculation
			update_Tire_friction_force()
			// angle calculations
			Aircraft__climb_angle = Math.Asin(Aircraft__rate_of_climb / Aircraft__true_air_speed) * 180 / Constants.Pi // for degree			
			Aircraft__angle_of_attack = (Aircraft__pitch - Aircraft__rate_of_climb)
			
			//help variable
			var Aircraft__climb_angle_rad = Aircraft__climb_angle * Constants.Pi / 180
			
			// Lift calculation - Note: True Airspeed needs to be used here!
			Aircraft__lift_coefficient = Get_Aircraft__lift_coefficient()
			Aircraft__lift = Aircraft__lift_coefficient * agentlayer.Get_Weather__density() * Aircraft__true_air_speed**2 * Aircraft__wing_area / 2
			
			// Drag calculation
			Aircraft__drag_coefficient = Get_Aircraft__drag_coefficient()
			Aircraft__drag = Aircraft__drag_coefficient * agentlayer.Get_Weather__density() * Aircraft__true_air_speed**2 * Aircraft__wing_area / 2
			
			//Z Movement calculation
			// TODO: The right angle is Aircraft__climb_angle here, but that would lead to VERY unstable behavior due to linking effects
			Aircraft__acceleration_z = ((Propeller__thrust - Tire__friction_force - Aircraft__drag) * Math.Sin(Aircraft__climb_angle_rad) + Aircraft__lift * Math.Cos(Aircraft__climb_angle_rad) - Aircraft__mass * agentlayer.Get_gravity()) / Aircraft__mass 
			Aircraft__rate_of_climb = Aircraft__rate_of_climb + Aircraft__acceleration_z / n_cycle
			Aircraft__height = Aircraft__height + Aircraft__rate_of_climb / n_cycle
			
			if (Aircraft__height < 0) //redundancy and deny negative values
			{
				Aircraft__rate_of_climb = 0
				Aircraft__height = 0
			}
			
			//X Movement calculation
			Aircraft__acceleration_x = ((Propeller__thrust - Tire__friction_force - Aircraft__drag - Brake__deceleration_force) * Math.Cos(Aircraft__climb_angle_rad) - Aircraft__lift * Math.Sin(Aircraft__climb_angle_rad)) / Aircraft__mass
			Aircraft__ground_speed_x = Aircraft__ground_speed_x + Aircraft__acceleration_x / n_cycle
			Aircraft__true_air_speed_x = Aircraft__ground_speed_x + agentlayer.Get_Weather__wind_speed() * Math.Cos(delta_wind_bearing_rad)
			// Remove values below zero for each speed
			if (Aircraft__true_air_speed_x < 0)
			{
				Aircraft__true_air_speed_x = 0
			}
			if (Aircraft__ground_speed_x < 0 or Brake__parking_brake === "SET")
			{
				Aircraft__ground_speed_x = 0
			}
			Aircraft__movement_x = Aircraft__movement_x + Aircraft__ground_speed_x / n_cycle
			
			// True Airspeed calculation
			Aircraft__true_air_speed = (Aircraft__true_air_speed_x**2 + Aircraft__rate_of_climb**2)**0.5
		}
		
		// TODO: Add ground speed calculation here !
		if (Aircraft__movement_x > 0)
		{
			move me Aircraft__movement_x to Aircraft__heading_bearing
		}
	}
		
	//-----Brake System-----
	observe var Brake__parking_brake : string // "SET" or "OFF"
	
	observe var Brake__deceleration_application : real // value No brakes applied 0...1 Full Brakes applied
	observe var Brake__deceleration_force : real // Newton
	var Brake__deceleration_force_max : real = 3000 // Newton
	
	//TODO: Add brake_health dependency on Tire inflation
	
	def initialize_Brake()
	{
		Brake__parking_brake = "SET" 
		Brake__deceleration_force = 0.0
		Brake__deceleration_application = 0.0
	}
	
	def update_Brake()
	{
		if (Aircraft__flight_phase === "on-ground")
		{
			Brake__deceleration_force = Brake__deceleration_application * Brake__deceleration_force_max
		}
		else
		{
			Brake__deceleration_force = 0
		}
	}
	
	
	// -----Propeller-----
	var Propeller__diameter : real = 1.75 // meters
	observe var Propeller__thrust : real // newton
	
	// Thrust Coefficient (See Excel "Calculation Table")
	observe var Propeller__thrust_coefficient : real
	var Propeller__thrust_coefficient_slope : real // has to be initialized, since negative and Mars does not allow direct negative number assignment
	var Propeller__thrust_coefficient_constant : real = 0.1
	var Propeller__thrust_coefficient_speed_constant : real = 25.0 //Up to which speed coefficient is constant
	def Get_Propeller__thrust_coefficient()
	{
		if (Aircraft__true_air_speed > Propeller__thrust_coefficient_speed_constant)
		{
			Propeller__thrust_coefficient = Propeller__thrust_coefficient_slope * (Aircraft__true_air_speed - Propeller__thrust_coefficient_speed_constant) + Propeller__thrust_coefficient_constant
		}
		else
		{
			Propeller__thrust_coefficient = Propeller__thrust_coefficient_constant
		}
		
		if (Propeller__thrust_coefficient < 0)
		{
			Propeller__thrust_coefficient = 0
		}
		return Propeller__thrust_coefficient
	}
	
	
	def initialize_Propeller()
	{
		Propeller__thrust = 0.0
		
		Propeller__thrust_coefficient_slope = -0.002
	}
	
	def update_Propeller()
	{
		// Propeller thrust calculation
		Propeller__thrust_coefficient = Get_Propeller__thrust_coefficient()
		Propeller__thrust = Propeller__thrust_coefficient * agentlayer.Get_Weather__density() * (Engine__RPM/60)**2 * Propeller__diameter**4
	}
	
	// -----Engine-----
	observe var Engine__oil : real  // litre
	observe var Engine__oil_pressure : real // normal between 205000 and 410000 Pa
	observe var Engine__oil_temperature : real // normal between 38째C and 116째C
	observe var Engine__mixture_control : string  // either "RICH" or "LEAN"
	observe var Engine__throttle : real  // percentage NO THROTTLE 0..1 FULL THROTTLE
	observe var Engine__power : real // between 0W and 75000W 
	observe var Engine__ignition_switch : string  // "OFF", "BOTH" or "START" (not used so far: "L", "R")
	observe var Engine__RPM : real  //calculated via formula with power coefficient
	observe var Engine__running : bool
	observe var Engine__failure_probability : real // percentage per tick 0..1
	observe var Engine__failure : bool
	observe var Engine__fuel_consumption : real // liters/s
	observe var Engine__oil_pump_condition : bool // either true (healthy) or false (faulty)
	observe var Engine__oil_leakage : real // either 0 or low value
	
	//Power Coefficient (See Excel "Calculation Table")
	//Note: assumption cp = f(V/(n*d)) with n*d=1
	var Engine__power_coefficient : real
	var Engine__power_coefficient_slope : real // has to be initialized, since negative and Mars does not allow direct negative number assignment
	var Engine__power_coefficient_constant : real = 0.05
	var Engine__power_coefficient_speed_constant : real = 30.0 //Up to which speed coefficient is constant
	
	def Get_Engine__power_coefficient()
	{
		if (Aircraft__true_air_speed > Engine__power_coefficient_speed_constant)
		{
			Engine__power_coefficient = Engine__power_coefficient_slope * (Aircraft__true_air_speed - Engine__power_coefficient_speed_constant) + Engine__power_coefficient_constant
		}
		else
		{
			Engine__power_coefficient = Engine__power_coefficient_constant
		}
		return Engine__power_coefficient
	}

	//Settings
	var Engine__oil_max : integer = 6
	var Engine__oil_min : integer = 4
	var Engine__oil_critical_min : integer = 3
	var Engine__oil_pressure_normal_min = 205000
	var Engine__oil_pressure_normal_max = 410000
	var Engine__oil_temperature_normal_min = 38 // normal value, but higher one would be better for linear assumption in calculation later
	var Engine__oil_temperature_normal_max = 116
	var Engine__RPM_max : integer = 2750
	var Engine__power_max : integer = 75000 // W
	var Engine__fuel_consumption_max : real = 0.0079 // liters/s (correspond to 7.5 gallon per hour)
	
	passive Get_Engine__oil_min() => return Engine__oil_min
	passive Get_Engine__oil_temperature_normal_max() => return Engine__oil_temperature_normal_max
	passive Get_Engine__oil_pressure_normal_min() => return Engine__oil_pressure_normal_min
	
	// TODO: Help function as long as handling for TakeOff and Taxi is being difficult
	passive Get_Engine__failure() => return Engine__failure
	
	def initialize_Engine()
	{
		Engine__oil_pump_condition = Utility.probability_check(0.98) // either true (98%) or false
		Engine__oil_leakage = 0.0
		if (Utility.probability_check(0.02) === true)
		{
			Engine__oil_leakage = 0.01
		}
		Engine__oil = 3.1 + random(3) + (random(10) / 10.0)
		Engine__mixture_control = #["LEAN", "RICH"].Get(random(2))
		Engine__throttle = random(10) / 10.0
		Engine__ignition_switch = "OFF"
		Engine__RPM = 0.0
		Engine__power = 0.0
		Engine__running = false
		Engine__oil_pressure = 101325 //TODO: Set equal to ambient pressure
		Engine__oil_temperature = 15
		Engine__failure_probability = 10**(-6)
		Engine__failure = false
		Engine__fuel_consumption = 0.0
		
		Engine__power_coefficient_slope = -0.0009	
	}
	
	
	def Set_Engine__not_running_values()
	{
		Engine__running = false
		Engine__RPM = 0.0
		Engine__power = 0.0
		Engine__oil_pressure = 101325
		Engine__oil_temperature = 15
		Engine__fuel_consumption = 0.0
	}
	
	def Add_Engine__failure_probability(add : real) => Engine__failure_probability = Engine__failure_probability + add
	def Calculate_Engine__failure_probability()
	{
		Engine__failure_probability = 10**(-6)
		if (RWT__water_sediments === true)
		{
			Add_Engine__failure_probability(10**(-4))
		}
		if (LWT__water_sediments === true)
		{
			Add_Engine__failure_probability(10**(-4))
		}
		if (Engine__oil < Engine__oil_min)
		{
			Add_Engine__failure_probability(5 * 10**(-4))
		}
		if (Engine__oil < Engine__oil_critical_min)
		{
			Add_Engine__failure_probability(5 * 10**(-2))
		}
		if (Engine__oil_pump_condition === false)
		{
			Add_Engine__failure_probability(5 * 10**(-4))
		}
		if (Engine__mixture_control === "LEAN")
		{
			Add_Engine__failure_probability(10**(-4))
		}
	}
	
	// used in aircraft physics directly
	def update_Engine_RPM()
	{
		//Engine RPM Calculation
		Engine__power_coefficient = Get_Engine__power_coefficient()
		Engine__RPM = (Engine__power/(Engine__power_coefficient*agentlayer.Get_Weather__density()*Propeller__diameter**5))**0.3333 * 60 // FACTOR 60 TO CONVERT INTO PER MINUTE
		if (Engine__RPM > Engine__RPM_max)
		{
			Engine__RPM = Engine__RPM_max
		}
	}
	
	def update_Engine()
	{
		if (Engine__running === false or Engine__failure === true)
		{
			Set_Engine__not_running_values()
			if (Engine__ignition_switch === "START" and CIP__master_switch === "ON" and Engine__failure === false)
			{
				if (random(100) <= 40) // 40% chance for engine to start
				{
					//println "The engine started successfully."
					Engine__running = true
				}
			}
		}
		
		if (Engine__running === true and Engine__failure === false)
		{
			//Engine Power Calculation
			Engine__power = Engine__power_max * Engine__throttle
			if (Engine__mixture_control === "LEAN")
			{
				Engine__power = Engine__power - Engine__power * 0.1 // simulating power loss due to wrong settings during on ground
			}
			
			// Engine Failure Probability
			Calculate_Engine__failure_probability()
			if (Utility.probability_check(Engine__failure_probability) === true)
			{
				event_info = "Engine Failure"
				Engine__failure = true
			}
			
			// Engine turned off
			if (Engine__ignition_switch === "OFF")
			{
				Engine__running = false
			}
			
			// Engine fuel_consumption
			Engine__fuel_consumption = Engine__fuel_consumption_max * Engine__throttle 
			
			//Engine Oil
			Engine__oil = Engine__oil - Engine__oil_leakage
			var Engine__oil_temperature_slope = (Engine__oil_temperature_normal_min - Engine__oil_temperature_normal_max) / (Engine__oil_max - Engine__oil_min)
			var Engine__oil_pressure_slope = (Engine__oil_pressure_normal_max - Engine__oil_pressure_normal_min) / (Engine__oil_max - Engine__oil_min)
			Engine__oil_pressure = (Engine__oil_pressure_normal_min - Engine__oil_pressure_slope * Engine__oil_min) + Engine__oil_pressure_slope * Engine__oil
			Engine__oil_temperature = (Engine__oil_temperature_normal_max - Engine__oil_temperature_slope * Engine__oil_min) + Engine__oil_temperature_slope * Engine__oil
			if (Engine__oil_pump_condition === false)
			{
				// simulating faulty engine pump values
				Engine__oil_temperature = Engine__oil_temperature + (Engine__oil_temperature_normal_max - Engine__oil_temperature_normal_min)/2
				Engine__oil_pressure = Engine__oil_pressure - (Engine__oil_pressure_normal_max - Engine__oil_pressure_normal_min)/2
			}
			if (Engine__oil_pressure < 101325)
			{
				Engine__oil_pressure = 101325
			}
		}
	}
	
	passive Get_Engine__running() => return Engine__running
	passive Get_Engine__oil() => return Engine__oil
	passive Refill_Engine__oil() => Engine__oil = Engine__oil_max
	
	
	
	// -----Right Wing Tank (RWT)-----
	// Note: Right - and LeftWingTank (RWT&LWT)
	observe var RWT__fuel_quantity : real 
	observe var RWT__water_sediments : bool
	var RWT__total_capacity : integer = 49 // Litre
		
	passive Get_RWT__fuel_quantity() => return RWT__fuel_quantity
	passive Get_RWT__water_sediments() => return RWT__water_sediments
	passive Repair_RWT__water_sediments() => RWT__water_sediments = false
	
	def initialize_RightWingTank()
	{
		RWT__fuel_quantity = random(RWT__total_capacity+1)
		RWT__water_sediments = Utility.probability_check(0.5) // either true or false
	}
	
	def update_RightWingTank()
	{
		RWT__fuel_quantity = RWT__fuel_quantity - Engine__fuel_consumption/2 //half to each tank
	}
	
	// -----Left Wing Tank (LWT)-----
	observe var LWT__fuel_quantity : real // Litre
	observe var LWT__water_sediments : bool
	var LWT__total_capacity : integer = 49 // Litre
	
	passive Get_LWT__fuel_quantity() => return LWT__fuel_quantity // return of fuel quantity "visual"
	passive Get_LWT__water_sediments() => return LWT__water_sediments
	passive Repair_LWT__water_sediments() => LWT__water_sediments = false
	
	def initialize_LeftWingTank()
	{
		LWT__fuel_quantity = random(LWT__total_capacity+1)
		LWT__water_sediments = Utility.probability_check(0.5) // either true or false
	}
	
	def update_LeftWingTank()
	{
		LWT__fuel_quantity = LWT__fuel_quantity - Engine__fuel_consumption/2 //half to each tank
	}	
	
	
	// -----Tire-----
	observe var TireRightMainWheel__inflation : integer
	observe var TireLeftMainWheel__inflation : integer
	observe var TireNoseWheel__inflation : integer
	var TireRightMainWheel__inflation_max : integer = 145000
	var TireLeftMainWheel__inflation_max : integer = 145000
	var TireNoseWheel__inflation_max : integer = 207000
	var Tire__number_of_wheels : integer = 3
	var Tire__wheel_radius : real = 0.075 //meter; neglecting non equal size of nose and main wheels
	
	// Friction Calculation (See Excel "Calculation table")
	observe var Tire__friction_force : real //newton
	var Tire__roll_coefficient : real = 0.002 //meters
	
	def initialize_Tire()
	{
		//Inflation with 1% Chance that a Tire is not fully inflated
		if (random(100) <= 99)
		{
			TireRightMainWheel__inflation = TireRightMainWheel__inflation_max
		}
		else
		{
			TireRightMainWheel__inflation = random(TireRightMainWheel__inflation_max)
		}
		
		if (random(100) <= 99)
		{
			TireLeftMainWheel__inflation = TireLeftMainWheel__inflation_max
		}
		else
		{
			TireLeftMainWheel__inflation = random(TireLeftMainWheel__inflation_max)
		}
		
		if (random(100) <= 99)
		{
			TireNoseWheel__inflation = TireNoseWheel__inflation_max
		}
		else
		{
			TireNoseWheel__inflation = random(TireNoseWheel__inflation_max)
		}
		
		Tire__friction_force = 0
	}
	
	// used in aircraft physics directly
	def update_Tire_friction_force()
	{
		//TODO: Add friction dependency on Tire inflation
		if (Aircraft__flight_phase === "on-ground")
		{
			Tire__friction_force = (Aircraft__mass * agentlayer.Get_gravity() - Aircraft__lift) * Tire__number_of_wheels * Tire__roll_coefficient / Tire__wheel_radius
		}
		else
		{
			Tire__friction_force = 0
		}
		
		if (Tire__friction_force < 0)
		{
			Tire__friction_force = 0
		}		
	}
	
	passive Get_TireRightMainWheel__inflation() => return TireRightMainWheel__inflation
	passive Get_TireLeftMainWheel__inflation() => return TireLeftMainWheel__inflation
	passive Get_TireNoseWheel__inflation() => return TireNoseWheel__inflation
	
	
	
	//-----Control_Input_Panel(CIP)-----
	// Interface for pilot input when sitting in Aircraft for giving Input
	
	// master switch here, since placing in other classes difficult
	observe var CIP__master_switch : string // "ON" or "OFF"
	
	def initialize_CIP()
	{
		CIP__master_switch = "OFF" 
	}
	
	passive CIP_Set_Engine__ignition_switch(input : string)
	{
		Engine__ignition_switch = input
	}

	passive CIP_Apply_Engine__throttle(input: real)
	{
		Engine__throttle = input
		
		// redundancy
		if (Engine__throttle < 0)
		{
			Engine__throttle = 0
		}
		else if (Engine__throttle > 1)
		{
			Engine__throttle = 1
		}
	}
	
	//Both function works as heading input, since calculation for heading within pilot not yet integrated
	passive CIP_Set_Aircraft__heading_bearing(input : real)
	{
		Aircraft__heading_bearing = input
	}
	
	passive CIP_Apply_Aircraft__pitch(input : real)
	{
		Aircraft__pitch = input
	}
	
	passive CIP_Set__master_switch(input: string)
	{
		CIP__master_switch = input
	}	
	
	passive CIP_Set_Brake__parking_brake(input : string)
	{
		Brake__parking_brake = input
	}
	
	passive CIP_Apply_Brake__deceleration(input : real)
	{
		Brake__deceleration_application = input
	}
	
	passive CIP_Set_Engine__mixture_control(input : string)
	{
		Engine__mixture_control = input
	}
	
	
	
	//-----Instrument_Panel(IP)-----
	// Interface for pilot input when sitting in Aircraft for reading Instruments
	
	passive IP_Get_Engine__oil_pressure()
	{
		return Engine__oil_pressure()
	}
	
	passive IP_Get_Engine__oil_temperature()
	{
		return Engine__oil_temperature()
	}
	
	//airspeed_indicator
	passive IP_Get_Aircraft__true_air_speed()
	{
		//TODO: Right Aircraft Speed indication calculation after wind implementation
		return Aircraft__true_air_speed
	}
	
	//artificial_horizon
	passive IP_Get_Aircraft__pitch()
	{
		return Aircraft__pitch
	}
	
	//vertival speed indicator
	passive IP_Get_Aircraft__rate_of_climb()
	{
		return Aircraft__rate_of_climb
	}
	
	//altimeter
	passive IP_Get_Aircraft__height()
	{
		return Aircraft__height
	}
	
	//fuel indicator
	passive IP_Get_RWT__fuel_quantity()
	{
		return RWT__fuel_quantity
	}
	passive IP_Get_LWT__fuel_quantity()
	{
		return LWT__fuel_quantity
	}
	
	//tachometer
	passive IP_Get_Engine__RPM()
	{
		return Engine__RPM
	}
}

class UtilityClass
{
	def probability_check(probability : real) : bool
	// Probability Checker for events with a precision of 10^6
	{
		var random_value = random(10**6)/10**6
		if (random_value >= probability)
		{
			return false
		}
		else
		{
			return true
		}
	}
}
