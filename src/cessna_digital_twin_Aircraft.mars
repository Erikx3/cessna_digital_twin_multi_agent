model cessna_digital_twin

use Mars

agent Aircraft on AgentLayer{
	
	initialize
	{
		initialize_general_values()
		initialize_AircraftCharacteristics()
		initialize_RightWingTank()
		initialize_LeftWingTank()
		initialize_Tire()
		initialize_Brake()
		initialize_Engine()
		initialize_Propeller()
		initialize_AircraftPhysics()
		initialize_CIP()
	}
	
	tick
	{
		update_general_values()
		update_Engine()
		update_Propeller()
		update_Tire()
		update_Brake()
		update_AircraftPhysics()
	}
	
	
	
	// -----General Values and Functions (Settings and Doc)-----
	observe var Latitude : real
	observe var Longitude : real
	//TODO: Add calculation of heading between two point to pilot
	var Aircraft__heading_mode : string // either "BEARING" or "COORDINATES"	
	
	// TODO: Think about this for documentation
	//observe var passive_activity: string // activity by pilot is more precise
	//observe var malfunction_notification // maybe add something like this or think about it
	
	def initialize_general_values()
	{
		var x_spawn = agentlayer.Get_spawn_x_coord()
		var y_spawn = agentlayer.Get_spawn_y_coord()
		pos at #(x_spawn, y_spawn)
		
		Longitude = xcor
		Latitude = ycor
		Aircraft__heading_mode = "COORDINATES"
	}
	
	def update_general_values()
	{
		Longitude = xcor
		Latitude = ycor
	}
	
	passive Get_position() => return #(xcor, ycor) // for returning the position of the aircraft
	passive Set_Aircraft__heading_mode(input : string) => Aircraft__heading_mode = input
	
	
	//-----Aircraft Characteristics-----
	observe var Aircraft__callsign : string // IDENTIFIER!
	var Aircraft__mass : real = 725.0 // kg
	var Aircraft__wing_area : real = 15.0 // m^2
	var Aircraft__wing_span : real = 10.1 // m
	var Aircraft__stall_angle : real = 14.0 // deg
	
	def Get_Aircraft__aspect_ratio() => return Aircraft__wing_span**2 / Aircraft__wing_area
	
	def initialize_AircraftCharacteristics()
	{
		Aircraft__callsign = "Cessna" + random(10000) //TODO: Make sure, Callsign is Unique!
	}
	
	passive Get_callsign() => return Aircraft__callsign
	
	//-----Aircraft(Movement and Physics)-----
	observe var Aircraft__acceleration_x : real // m/s^2 with x in direction of plane heading
	observe var Aircraft__speed_x : real // m/s
	var Aircraft__movement_x : real // m
	var Aircraft__heading_bearing : integer //heading integer, usage depends on Aircraft_heading_mode
	var Aircraft__heading_coordinates : Tuple<real, real> //heading tuple coordinate
	
	observe var Aircraft__height : real // m
	observe var Aircraft__flight_phase : string // values "in-air" or "on-ground"
	observe var Aircraft__angle_of_attack : real // degree
	observe var Aircraft__lift : real //newton
	observe var Aircraft__acceleration_z : real // m/s^2 with z pointing upwards
	observe var Aircraft__climb_rate : real // m/s
	
	observe var Aircraft__drag : real // newton
	
	//lift coefficient calculation (See Excel "Calculation_Table")
	var Aircraft__lift_coefficient : real
	var Aircraft__lift_coefficient_slope : real = 4.9
	var Aircraft__zero_lift_angle : real 
	var Aircraft__total_stall_angle : real = 18.0 // deg, only for calculation purpose
	def Get_Aircraft__lift_coefficient()
	{
		if (Aircraft__angle_of_attack <= Aircraft__stall_angle)
		{
			Aircraft__lift_coefficient = (Aircraft__angle_of_attack - Aircraft__zero_lift_angle) * Constants.Pi / 180 * Aircraft__lift_coefficient_slope
		}
		else if (Aircraft__angle_of_attack >= Aircraft__total_stall_angle)
		{
			Aircraft__lift_coefficient = 0.0
		}
		else
		{
			Aircraft__lift_coefficient = (2 * Aircraft__zero_lift_angle - Aircraft__angle_of_attack) * Constants.Pi / 180 * Aircraft__lift_coefficient_slope
		}
		return Aircraft__lift_coefficient
	}
	
	//drag coefficient calculation (See Excel "Calculation_Table")
	observe var Aircraft__drag_coefficient : real
	var Aircraft__zero_lift_drag_coefficient : real = 0.04
	var Aircraft__oswald_factor : real = 0.7
	def Get_Aircraft__drag_coefficient()
	{
		Aircraft__drag_coefficient = Aircraft__zero_lift_drag_coefficient + Aircraft__lift_coefficient**2 /(Aircraft__oswald_factor * Constants.Pi * Get_Aircraft__aspect_ratio())
		return	Aircraft__drag_coefficient
	}
		
		
	def initialize_AircraftPhysics()
	{
		Aircraft__acceleration_x = 0.0
		Aircraft__speed_x = 0.0
		Aircraft__height = 0.0
		Aircraft__flight_phase = "on-ground"
		Aircraft__lift = 0.0
		Aircraft__acceleration_z = 0.0
		Aircraft__climb_rate = 0.0
		Aircraft__angle_of_attack = 0.0
		Aircraft__drag = 0.0
		
		Aircraft__zero_lift_angle = -3.0
	}
		
	def update_AircraftPhysics()
	{
		//Note: remember, Tick size is ONE second!
		//help variable
		var Aircraft__AoA_rad = Aircraft__angle_of_attack * Constants.Pi / 180
		// flight state
		if (Aircraft__height > 0)
		{
			Aircraft__flight_phase = "in-air"
		}
		else
		{
			Aircraft__flight_phase = "on-ground"
		}
		
		// Lift calculation
		Aircraft__lift_coefficient = Get_Aircraft__lift_coefficient()
		Aircraft__lift = Aircraft__lift_coefficient * agentlayer.Get_Weather__density() * Aircraft__speed_x**2 * Aircraft__wing_area / 2
		
		//Z Movement calculation
		Aircraft__acceleration_z = ((Propeller__thrust - Tire__friction_force - Aircraft__drag) * Math.Sin(Aircraft__AoA_rad) + Aircraft__lift * Math.Cos(Aircraft__AoA_rad) - Aircraft__mass * agentlayer.Get_gravity()) / Aircraft__mass 
		Aircraft__climb_rate = Aircraft__climb_rate + Aircraft__acceleration_z
		Aircraft__height = Aircraft__height + Aircraft__climb_rate
		
		if (Aircraft__height <= 0) //redundancy and deny negative values
		{
			Aircraft__climb_rate = 0
			Aircraft__height = 0
		}
		
		// Drag calculation
		Aircraft__drag_coefficient = Get_Aircraft__drag_coefficient()
		Aircraft__drag = Aircraft__drag_coefficient * agentlayer.Get_Weather__density() * Aircraft__speed_x**2 * Aircraft__wing_area / 2
	
		//X Movement calculation
		Aircraft__acceleration_x = ((Propeller__thrust - Tire__friction_force - Aircraft__drag) * Math.Cos(Aircraft__AoA_rad) - Aircraft__lift * Math.Sin(Aircraft__AoA_rad)) / Aircraft__mass - Brake__deceleration
		Aircraft__speed_x = Aircraft__speed_x + Aircraft__acceleration_x
		if (Aircraft__speed_x < 0 or Brake__parking_brake === "SET")
		{
			Aircraft__speed_x = 0
		}
		Aircraft__movement_x = Aircraft__speed_x
		
		if (Aircraft__movement_x > 0)
		{
			if (Aircraft__heading_mode === "COORDINATES")
			{
				move me Aircraft__movement_x to Aircraft__heading_coordinates
			}
			else if (Aircraft__heading_mode === "BEARING")
			{
				move me Aircraft__movement_x to Aircraft__heading_bearing
			}
		}
		
		
		
	}
		
	//-----Brake System-----
	observe var Brake__parking_brake : string // "SET" or "OFF"
	
	observe var Brake__deceleration_application : real // value No brakes applied 0...1 Full Brakes applied
	observe var Brake__deceleration : real // m/s^2
	var Brake__deceleration_max : real = 4 // m/s^2
	
	//TODO: Add brake_health dependency on Tire inflation
	
	def initialize_Brake()
	{
		Brake__parking_brake = "SET" 
		Brake__deceleration = 0.0
		Brake__deceleration_application = 0.0
	}
	
	def update_Brake()
	{
		Brake__deceleration = Brake__deceleration_application * Brake__deceleration_max
	}
	
	
	// -----Propeller-----
	var Propeller__diameter : real = 1.75 // meters
	observe var Propeller__thrust : real // newton
	
	// Thrust Coefficient (See Excel "Calculation Table")
	observe var Propeller__thrust_coefficient : real
	var Propeller__thrust_coefficient_slope : real // TODO: has to be initialized, since negative and Mars does not allow direct negative number assignment
	var Propeller__thrust_coefficient_constant : real = 0.1
	var Propeller__thrust_coefficient_speed_constant : real = 25.0 //Up to which speed coefficient is constant
	def Get_Propeller__thrust_coefficient()
	{
		if (Aircraft__speed_x > Propeller__thrust_coefficient_speed_constant)
		{
			Propeller__thrust_coefficient = Propeller__thrust_coefficient_slope * (Aircraft__speed_x - Propeller__thrust_coefficient_speed_constant) + Propeller__thrust_coefficient_constant
		}
		else
		{
			Propeller__thrust_coefficient = Propeller__thrust_coefficient_constant
		}
		return Propeller__thrust_coefficient
	}
	
	
	def initialize_Propeller()
	{
		Propeller__thrust = 0.0
		
		Propeller__thrust_coefficient_slope = -0.002
	}
	
	def update_Propeller()
	{
		// Propeller thrust calculation
		Propeller__thrust_coefficient = Get_Propeller__thrust_coefficient()
		Propeller__thrust = Propeller__thrust_coefficient * agentlayer.Get_Weather__density() * (Engine__RPM/60)**2 * Propeller__diameter**4
	}
	
	// -----Engine-----
	observe var Engine__oil : real  // litre
	observe var Engine__oil_pressure : real // normal between 205000 and 410000 Pa
	observe var Engine__oil_temperature : real // normal between 38°C and 116°C
	observe var Engine__mixture_control : real  // percentage RICH 0..1 LEAN
	observe var Engine__throttle : real  // percentage NO THROTTLE 0..1 FULL THROTTLE
	observe var Engine__power : real // between 0W and 75000W 
	observe var Engine__ignition_switch : string  // "OFF", "L", "R", "BOTH" or "START"
	observe var Engine__RPM : real  //calculated via formula with power coefficient
	observe var Engine__running : bool
	
	//Power Coefficient (See Excel "Calculation Table")
	//Note: assumption cp = f(V/(n*d)) with n*d=1
	var Engine__power_coefficient : real
	var Engine__power_coefficient_slope : real // TODO: has to be initialized, since negative and Mars does not allow direct negative number assignment
	var Engine__power_coefficient_constant : real = 0.05
	var Engine__power_coefficient_speed_constant : real = 30.0 //Up to which speed coefficient is constant
	
	def Get_Engine__power_coefficient()
	{
		if (Aircraft__speed_x > Engine__power_coefficient_speed_constant)
		{
			Engine__power_coefficient = Engine__power_coefficient_slope * (Aircraft__speed_x - Engine__power_coefficient_speed_constant) + Engine__power_coefficient_constant
		}
		else
		{
			Engine__power_coefficient = Engine__power_coefficient_constant
		}
		return Engine__power_coefficient
	}

	//Settings
	var Engine__oil_max : integer = 6
	var Engine__oil_normal : integer = 5
	var Engine__oil_min : integer = 4
	var Engine__oil_pressure_normal_min = 205000
	var Engine__oil_pressure_normal_max = 410000
	var Engine__oil_pressure_min = 70000
	var Engine__oil_temperature_normal_min = 38
	var Engine__oil_temperature_normal_max = 116
	var Engine__RPM_max : integer = 2750
	var Engine__power_max : integer = 75000 // W
	
	//TODO, dependent on throttle settings!
	//observe var Engine__fuel_consumption : real
	
	//TODO Think about implementation
	//observe var Engine__oil_pump_condition : bool
	//observe var Engine__oil_pressure_gauge_condition : bool
	//observe var Engine__oil_leakage : real
	
	
	def initialize_Engine()
	{
		Engine__oil = 3.1 + random(3) + (random(10) / 10.0)
		Engine__mixture_control = random(101) / 100.0
		Engine__throttle = random(10) / 10.0
		Engine__ignition_switch = "OFF"
		Engine__RPM = 0.0
		Engine__power = 0.0
		Engine__running = false
		Engine__oil_pressure = 101325
		Engine__oil_temperature = 15
		
		Engine__power_coefficient_slope = -0.0009	
	}
	
	def Set_Engine__not_running_values()
	{
		Engine__RPM = 0.0
		Engine__oil_pressure = 101325
		Engine__oil_temperature = 15
	}
	
	def update_Engine()
	{
		if (Engine__running === false)
		{
			Set_Engine__not_running_values()
			if (Engine__ignition_switch === "START" and CIP__master_switch === "ON")
			{
				if (random(100) <= 40) // 40% chance for engine to start
				{
					println "The engine started successfully."
					Engine__running = true
				}
			}
		}
		
		if (Engine__running === true)
		{
			//Engine RPM Calculation
			Engine__power = Engine__power_max * Engine__throttle
			Engine__power_coefficient = Get_Engine__power_coefficient()
			Engine__RPM = (Engine__power/(Engine__power_coefficient*agentlayer.Get_Weather__density()*Propeller__diameter**5))**0.3333 * 60 // FACTOR 60 TO CONVERT INTO PER MINUTE
			if (Engine__RPM > Engine__RPM_max)
			{
				Engine__RPM = Engine__RPM_max
			}
			
			//Engine Oil TODO: Make dependent on engine__oil_pump and possible leakage
			var temp_Engine__oil_pressure_normal_half = (Engine__oil_pressure_normal_max + Engine__oil_pressure_normal_min) / 2
			var temp_Engine__oil_temperature_normal_half = (Engine__oil_temperature_normal_max + Engine__oil_temperature_normal_min) / 2
			Engine__oil_pressure = temp_Engine__oil_pressure_normal_half // Normal Operations
			Engine__oil_temperature = temp_Engine__oil_temperature_normal_half //TODO: maybe add dependence to throttle here at least
			if (Engine__oil < Engine__oil_normal)
			{
				//TODO: Add effect on Engine failure probability
				Engine__oil_pressure = Engine__oil_pressure - ((temp_Engine__oil_pressure_normal_half - Engine__oil_pressure_normal_min) * (Engine__oil_normal - Engine__oil))
				Engine__oil_temperature = Engine__oil_temperature + ((Engine__oil_temperature_normal_max - temp_Engine__oil_temperature_normal_half) * (Engine__oil_normal - Engine__oil))
			}
			
			
		}
	}
	
	passive Get_Engine__running() => return Engine__running
	passive Get_Engine__oil() => return Engine__oil
	
	
	
	// -----Right Wing Tank (RWT)-----
	// Note: Right - and LeftWingTank (RWT&LWT)
	observe var RWT__fuel_quantity : real 
	observe var RWT__water_sediments : bool
	var RWT__total_capacity : integer = 49 // Litre
		
	passive Get_RWT__fuel_quantity() => return RWT__fuel_quantity
	passive Get_RWT__water_sediments() => return RWT__water_sediments
	
	def initialize_RightWingTank()
	{
		RWT__fuel_quantity = random(RWT__total_capacity+1)
		RWT__water_sediments = false
	}
	
	// -----Left Wing Tank (LWT)-----
	observe var LWT__fuel_quantity : real // Litre
	observe var LWT__water_sediments : bool
	var LWT__total_capacity : integer = 49 // Litre
	
	passive Get_LWT__fuel_quantity() => return LWT__fuel_quantity // return of fuel quantity "visual"
	passive Get_LWT__water_sediments() => return LWT__water_sediments
	
	def initialize_LeftWingTank()
	{
		LWT__fuel_quantity = random(LWT__total_capacity+1)
		LWT__water_sediments = false
	}
	
	
	
	
	// -----Tire-----
	observe var TireRightMainWheel__inflation : integer
	observe var TireLeftMainWheel__inflation : integer
	observe var TireNoseWheel__inflation : integer
	var TireRightMainWheel__inflation_max : integer = 145000
	var TireLeftMainWheel__inflation_max : integer = 145000
	var TireNoseWheel__inflation_max : integer = 207000
	var Tire__number_of_wheels : integer = 3
	var Tire__wheel_radius : real = 0.075 //meter; neglecting non equal size of nose and main wheels
	
	// Friction Calculation (See Excel "Calculation table")
	observe var Tire__friction_force : real //newton
	var Tire__roll_coefficient : real = 0.002 //meters
	
	def initialize_Tire()
	{
		//Inflation with 1% Chance that a Tire is not fully inflated
		if (random(100) <= 99)
		{
			TireRightMainWheel__inflation = TireRightMainWheel__inflation_max
		}
		else
		{
			TireRightMainWheel__inflation = random(TireRightMainWheel__inflation_max)
		}
		
		if (random(100) <= 99)
		{
			TireLeftMainWheel__inflation = TireLeftMainWheel__inflation_max
		}
		else
		{
			TireLeftMainWheel__inflation = random(TireLeftMainWheel__inflation_max)
		}
		
		if (random(100) <= 99)
		{
			TireNoseWheel__inflation = TireNoseWheel__inflation_max
		}
		else
		{
			TireNoseWheel__inflation = random(TireNoseWheel__inflation_max)
		}
		
		Tire__friction_force = 0
	}
	
	def update_Tire()
	{
		//TODO: Add friction dependency on Tire inflation
		if (Aircraft__flight_phase === "on-ground")
		{
			Tire__friction_force = Tire__number_of_wheels * Aircraft__mass * agentlayer.Get_gravity() * Tire__roll_coefficient / Tire__wheel_radius
		}
		else
		{
			Tire__friction_force = 0
		}		
	}
	
	passive Get_TireRightMainWheel__inflation() => return TireRightMainWheel__inflation
	passive Get_TireLeftMainWheel__inflation() => return TireLeftMainWheel__inflation
	passive Get_TireNoseWheel__inflation() => return TireNoseWheel__inflation
	
	
	
	//-----Control_Input_Panel(CIP)-----
	// Interface for pilot input when sitting in Aircraft for giving Input
	
	// master switch here, since placing in other classes difficult
	observe var CIP__master_switch : string // "ON" or "OFF"
	
	def initialize_CIP()
	{
		CIP__master_switch = "OFF" 
	}
	
	passive CIP_Set_Engine__ignition_switch(input : string)
	{
		Engine__ignition_switch = input
	}

	passive CIP_Apply_Engine__throttle(input: real)
	{
		Engine__throttle = input
		
		// redundancy
		if (Engine__throttle < 0)
		{
			Engine__throttle = 0
		}
		else if (Engine__throttle > 1)
		{
			Engine__throttle = 1
		}
	}
	
	//Both function works as heading input, since calculation for heading within pilot not yet integrated
	passive CIP_Set_Aircraft__heading_bearing(input : integer)
	{
		Aircraft__heading_bearing = input
	}
	passive CIP_Set_Aircraft__heading_coordinates(input : Tuple<real, real>)
	{
		Aircraft__heading_coordinates = input
	}
	
	passive CIP_Apply_Aircraft__pitch(input : real)
	{
		Aircraft__angle_of_attack = input
	}
	
	passive CIP_Set__master_switch(input: string)
	{
		CIP__master_switch = input
	}	
	
	passive CIP_Set_Brake__parking_brake(input : string)
	{
		Brake__parking_brake = input
	}
	
	passive CIP_Apply_Brake__deceleration(input : real)
	{
		Brake__deceleration_application = input
	}
	
	passive CIP_Set_Engine__mixture_control(input : real)
	{
		Engine__mixture_control = input
	}
	
	
	
	//-----Instrument_Panel(IP)-----
	// Interface for pilot input when sitting in Aircraft for reading Instruments
	
	passive IP_Get_Engine__oil_pressure()
	{
		return Engine__oil_pressure()
	}
	
	passive IP_Get_Engine__oil_temperature()
	{
		return Engine__oil_temperature()
	}
	
	//airspeed_indicator
	passive IP_Get_Aircraft__speed_x()
	{
		//TODO: Right Aircraft Speed indication calculation
		return Aircraft__speed_x
	}
	
	//artificial_horizon
	passive IP_Get_Aircraft__angle_of_attack()
	{
		return Aircraft__angle_of_attack
	}
	
	//vertival speed indicator
	passive IP_Get_Aircraft__climb_rate()
	{
		return Aircraft__climb_rate
	}
	
	//altimeter
	passive IP_Get_Aircraft__height()
	{
		return Aircraft__height
	}
	
	//fuel indicator
	passive IP_Get_RWT__fuel_quantity()
	{
		return RWT__fuel_quantity
	}
	passive IP_Get_LWT__fuel_quantity()
	{
		return LWT__fuel_quantity
	}
	
	//tachometer
	passive IP_Get_Engine__RPM()
	{
		return Engine__RPM
	}
}

